<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PIXELSTORTION // JUKEBOX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0"
        rel="stylesheet" />

    <style>
        :root {
            --neon-green: #00ff41;
            --fire-orange: #ff4500;
            --void: #050505;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void);
            overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
            cursor: crosshair;
        }

        /* --- VISUAL LAYERS --- */

        /* Layer 0: Narrative Gallery */
        #bg-gallery {
            position: fixed;
            inset: 0;
            z-index: 1;
            overflow: hidden;
            background: #000;
        }

        .gallery-img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            /* NO BLUR. Just dimmed and slightly desaturated for UI contrast */
            filter: brightness(0.5) grayscale(0.2);
            transform: scale(1.05);
            transition: opacity 2s ease, transform 15s ease-out;
        }

        .gallery-img.active {
            opacity: 1.0;
            transform: scale(1.0);
            /* Gentle drift */
        }

        /* Layer 1: Fluid Canvas */
        #fluid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            /* Screen mode drops out black, showing the fluid over the images */
            mix-blend-mode: screen;
            /* Soften the fluid layer so it acts like a delicate fog */
            opacity: 0.65;
        }

        .scanlines {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.2) 50%,
                    rgba(0, 0, 0, 0.6) 100%);
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
            opacity: 0.7;
        }

        /* Layer 5: Vignette — heavy, frames the narrative images into the void */
        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(5, 5, 5, 0.6) 60%, #050505 85%);
            z-index: 5;
            pointer-events: none;
        }

        /* --- UI LAYERS --- */
        #ui-layer {
            position: fixed;
            inset: 0;
            z-index: 20;
            pointer-events: none;
            /* Let clicks pass to fluid */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .interactive {
            pointer-events: auto;
        }

        /* --- TYPOGRAPHY --- */
        .glitch-text {
            font-family: 'Space Grotesk', sans-serif;
            text-transform: uppercase;
            position: relative;
            color: white;
            mix-blend-mode: difference;
        }

        .font-mono-custom {
            font-family: 'Courier Prime', monospace;
        }

        /* --- CONTROLS --- */
        .control-btn {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .control-btn:hover {
            border-color: var(--neon-green);
            color: var(--neon-green);
            transform: scale(1.1);
            background: rgba(0, 20, 0, 0.6);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* --- PROGRESS BAR --- */
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 1rem;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border-radius: 3px;
        }

        .progress-bar {
            height: 100%;
            background: var(--neon-green);
            width: 0%;
            box-shadow: 0 0 12px var(--neon-green),
                0 0 40px rgba(0, 255, 65, 0.3);
            transition: width 0.1s linear;
        }

        /* --- HIDDEN YOUTUBE (Covered Visible Player Pattern) --- */
        /* Player must remain on-screen to avoid browser throttling. */
        /* Pushed behind the gallery layer (z-index -2). */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            overflow: hidden;
            z-index: -2;
            pointer-events: none;
        }

        /* --- START OVERLAY --- */
        #start-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .start-btn {
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 20px 60px;
            font-family: 'Courier Prime', monospace;
            font-size: 1.2rem;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            display: none;
            /* Hidden until ready */
        }

        .start-btn:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
        }

        /* --- TRACK DATE --- */
        #track-date {
            min-height: 1.2em;
        }

        /* --- PHASE 1: MICRO-CORRUPTION LAYER --- */
        @keyframes micro-glitch {
            0% {
                transform: translate(0, 0);
            }

            20% {
                transform: translate(-1px, 1px);
            }

            40% {
                transform: translate(1px, -1px);
            }

            60% {
                transform: translate(-1px, -1px);
            }

            80% {
                transform: translate(1px, 1px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        .glitch-pulse {
            animation: micro-glitch 0.15s linear 1;
        }

        /* --- PHASE 6: ARCHIVE MODE INVERSION --- */
        .archive-mode {
            filter: invert(1) hue-rotate(180deg);
            transition: filter 0.6s ease;
        }

        /* --- PHASE 7: GPU POSTFX CANVAS --- */
        #postfx-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            mix-blend-mode: screen;
            pointer-events: none;
            opacity: 0.7;
        }

        /* --- PHASE 8: WHISPER OVERLAY --- */
        #whisper-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 25;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .whisper-fg {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: 1.1rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            text-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            opacity: 0;
            transition: opacity 0.35s ease;
            max-width: 60%;
            text-align: center;
        }

        .whisper-bg {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.15);
            opacity: 0;
            transition: opacity 0.5s ease;
            max-width: 50%;
            text-align: center;
        }

        /* --- PHASE 9: BRANCH + EVIDENCE TAGS --- */
        #evidence-tag {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 25;
            pointer-events: none;
            font-family: 'Courier Prime', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: rgba(0, 255, 65, 0.35);
            text-align: right;
            line-height: 1.6;
            transition: color 0.8s ease;
        }

        /* --- DEBUG OVERLAY --- */
        #debug-overlay {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 200;
            pointer-events: none;
            font-family: 'Courier Prime', monospace;
            font-size: 0.6rem;
            color: rgba(0, 255, 65, 0.7);
            background: rgba(0, 0, 0, 0.6);
            padding: 0.5rem 0.8rem;
            display: none;
            line-height: 1.5;
            border: 1px solid rgba(0, 255, 65, 0.2);
        }
    </style>
</head>

<body>

    <!-- NARRATIVE GALLERY (Layer 0) -->
    <div id="bg-gallery">
        <img id="gallery-img-a" class="gallery-img active" />
        <img id="gallery-img-b" class="gallery-img" />
    </div>

    <!-- VISUALS -->
    <canvas id="fluid-canvas"></canvas>
    <canvas id="postfx-canvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- WHISPER OVERLAY -->
    <div id="whisper-overlay">
        <div class="whisper-fg" id="whisper-fg"></div>
        <div class="whisper-bg" id="whisper-bg"></div>
    </div>

    <!-- EVIDENCE TAG -->
    <div id="evidence-tag">
        EVIDENCE CLASS: PENDING<br>
        MEMORY INTEGRITY: UNKNOWN<br>
        NARRATIVE CONFIDENCE: —
    </div>

    <!-- DEBUG OVERLAY -->
    <div id="debug-overlay" id="debug-overlay"></div>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1 class="text-4xl md:text-6xl font-bold text-white mb-8 tracking-tighter">PIXELSTORTION</h1>
        <button id="init-btn" class="start-btn" onclick="startSystem()">INITIALIZE SYSTEM</button>
        <p id="loading-text" class="mt-4 text-gray-500 font-mono-custom text-xs animate-pulse">ESTABLISHING UPLINK...
        </p>
    </div>

    <!-- UI OVERLAY -->
    <div id="ui-layer">

        <!-- TOP BAR -->
        <div class="flex justify-between items-start">
            <div>
                <div class="text-[10px] text-green-500 font-mono-custom tracking-[0.2em] mb-1">CURRENT TRACK</div>
                <h1 id="track-title"
                    class="text-4xl md:text-7xl font-bold text-white leading-none tracking-tighter mix-blend-difference mb-2">
                    SILENCE</h1>
                <h2 id="track-artist" class="text-xl md:text-2xl text-gray-400 font-light">WAITING FOR INPUT...</h2>
                <h3 id="track-date" class="text-sm text-green-700 font-mono-custom tracking-widest mt-1"></h3>
            </div>

            <div class="text-right hidden md:block">
                <div class="text-[10px] text-gray-500 font-mono-custom tracking-[0.2em]">SYSTEM STATUS</div>
                <div id="status-indicator" class="text-green-500 font-bold">STANDBY</div>
            </div>
        </div>

        <!-- CENTER (Empty for visuals) -->

        <!-- BOTTOM CONTROLS -->
        <div class="w-full max-w-4xl mx-auto interactive">

            <!-- Controls -->
            <div class="flex items-center justify-center gap-6 mb-4">
                <button class="control-btn" onclick="jukebox.prev()">
                    <span class="material-symbols-outlined">skip_previous</span>
                </button>

                <button class="control-btn" style="width: 80px; height: 80px; border-color: white;"
                    onclick="jukebox.togglePlay()">
                    <span id="play-icon" class="material-symbols-outlined" style="font-size: 40px;">play_arrow</span>
                </button>

                <button class="control-btn" onclick="jukebox.next()">
                    <span class="material-symbols-outlined">skip_next</span>
                </button>

                <button class="control-btn" onclick="toggleFullscreen()">
                    <span class="material-symbols-outlined">fullscreen</span>
                </button>
            </div>

            <!-- Progress -->
            <div class="flex justify-between text-xs font-mono-custom text-gray-500 px-1">
                <span id="curr-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
            <div class="progress-container" onclick="jukebox.seek(event)">
                <div id="progress-bar" class="progress-bar"></div>
            </div>

            <div class="text-center mt-4">
                <p id="catalogue-label" class="text-[10px] text-gray-600 font-mono-custom uppercase tracking-widest">
                    Catalogue: 50 Tracks // Mode: Random Access
                </p>
            </div>
        </div>
    </div>

    <!-- HIDDEN PLAYER -->
    <div id="video-container">
        <div id="player"></div>
    </div>

    <!-- FLUID ENGINE SCRIPT (External Library) -->
    <script src="js/fluid-simulator.js"></script>

    <!-- JUKEBOX LOGIC -->
    <script>
        // --- DATA ARCHIVE ---
        // galleryTrack maps to keys in gallery_map.json. storyDate from narrative metadata.
        const SONG_ARCHIVE = [
            { id: 2, title: "The Drop 1", artist: "Ethel", videoId: "zHWwhom80go", storyDate: "NOV 14, 2016 (AGE 15)", galleryTrack: "track_02" },
            { id: 4, title: "The Drop 2", artist: "Ethel", videoId: "K0ILO8MwX4Y", storyDate: "NOV 14, 2016 (AGE 15)", galleryTrack: "track_04" },
            { id: 6, title: "Polished Vomit", artist: "Isla", videoId: "MhEeDcdscrs", storyDate: "FEB 14, 2019 (THE WEDDING)", galleryTrack: "track_06" },
            { id: 8, title: "Structural Psychopathy", artist: "Dominic", videoId: "8rvIVBLZg2o", storyDate: "MAR 2019 (PROFILE)", galleryTrack: "track_08" },
            { id: 10, title: "Ride", artist: "Ethel", videoId: "0sgcZRtPO6s", storyDate: "JAN 20, 2024 (AGE 17)", galleryTrack: "track_10" },
            { id: 12, title: "Grief", artist: "Ethel", videoId: "PMy76HBgpL8", storyDate: "FEB 28, 2024 (THE CRASH)", galleryTrack: "track_12" },
            { id: 14, title: "Gotta Move", artist: "Ethel", videoId: "06qE_-OeIT0", storyDate: "MAR 02, 2024 (LEAVING HOME)", galleryTrack: "track_14" },
            { id: 16, title: "Won't Break Where Others End", artist: "Ethel", videoId: "fJNMlT7UeW0", storyDate: "MAR 05, 2024 (MOSMAN)", galleryTrack: "track_16" },
            { id: 18, title: "Big House", artist: "Ethel", videoId: "mj9MGf-VzJY", storyDate: "MAR 05, 2024 (MOSMAN)", galleryTrack: "track_18" },
            { id: 20, title: "Peek-A-Boo", artist: "Isla", videoId: "qbFxG7sK0pE", storyDate: "MAR 10, 2024 (MOSMAN)", galleryTrack: "track_20" },
            { id: 22, title: "Northern Road", artist: "Dominic", videoId: "P19KBEQdVjQ", storyDate: "MAR 15, 2024", galleryTrack: "track_22" },
            { id: 24, title: "Isla Hates Married Bankers", artist: "Isla", videoId: "sXKAs0U8eO8", storyDate: "MAY 2024", galleryTrack: "track_24" },
            { id: 26, title: "I Built A Box", artist: "Ethel", videoId: "0F_prk5dGC4", storyDate: "JUN 2024 (THE SAFE HOUSE)", galleryTrack: "track_26" },
            { id: 28, title: "Isla's Burning Dominic's Bridge", artist: "Isla", videoId: "nVKkwb4EnRc", storyDate: "AUG 2024 (THE LEAK)", galleryTrack: "track_28" },
            { id: 30, title: "For You!!!", artist: "Ethel", videoId: "f8o7zb3F-Xk", storyDate: "SEP 2024", galleryTrack: "track_30" },
            { id: 32, title: "Isla's Broken Edge", artist: "Isla", videoId: "_gvv_W5_x10", storyDate: "OCT 2024", galleryTrack: "track_32" },
            { id: 34, title: "Hero Complex", artist: "Dominic", videoId: "YkQOXPzYkkU", storyDate: "FEB 2020 (THE TRIAL START)", galleryTrack: "track_34" },
            { id: 36, title: "Nothing True", artist: "Ethel", videoId: "Ghg7pC3ms3I", storyDate: "APR 2020 (THE TESTIMONY)", galleryTrack: "track_36" },
            { id: 38, title: "You Will Thank Me Later", artist: "Dominic", videoId: "n6OgobffCzo", storyDate: "JUN 2020 (PRISON)", galleryTrack: "track_38" },
            { id: 39, title: "No Sparrow Caught Mid Flight", artist: "Ethel", videoId: "t6vLU0uqIfc", storyDate: "DEC 2024 (POST-TRIAL)", galleryTrack: "track_39" },
            { id: 41, title: "Dominic's Escape", artist: "Dominic", videoId: "6eZwBGXGSO4", storyDate: "JAN 2024 (THE ESCAPE)", galleryTrack: "track_41" },
            { id: 42, title: "Ethel's Story - Overview", artist: "Ethel", videoId: "dLUClmr_Pf4", storyDate: "(ARCHIVE REVIEW)", galleryTrack: "track_42" },
            { id: 43, title: "Ethel's Conclusion", artist: "Ethel", videoId: "D5afy4FucwA", storyDate: "(ARCHIVE REVIEW)", galleryTrack: "track_43" },
            { id: 44, title: "Ethel:Spoken: Projection", artist: "Ethel", videoId: "AOktpmGD0Po", storyDate: "UNKNOWN", galleryTrack: "track_44" },
            { id: 45, title: "Platform 18", artist: "Ethel", videoId: "VC6vQGPyF4c", storyDate: "UNKNOWN", galleryTrack: "track_45" },
            { id: 46, title: "Kinley (Guilt Money)", artist: "Kinley", videoId: "Ac3cRsmjKpE", storyDate: "UNKNOWN", galleryTrack: "track_46" },
            { id: 47, title: "Ants On The Vine", artist: "Ethel", videoId: "CaBcQ2aSjog", storyDate: "UNKNOWN", galleryTrack: "track_47" },
            { id: 48, title: "Rattled", artist: "Ethel", videoId: "Fs7BXBOVnvY", storyDate: "UNKNOWN", galleryTrack: "track_48" },
            { id: 49, title: "Clipboard Man", artist: "Ethel", videoId: "ZAhqNWTHTGU", storyDate: "UNKNOWN", galleryTrack: "track_49" },
            { id: 50, title: "Make A Mistake On Purpose", artist: "Ethel", videoId: "s9Z8dgRk-Q8", storyDate: "UNKNOWN", galleryTrack: "track_50" },
            { id: 51, title: "Red Stick", artist: "Ethel", videoId: "iTOKsLS3jhM", storyDate: "UNKNOWN", galleryTrack: "track_51" },
            { id: 52, title: "Harms Ghost", artist: "Ethel", videoId: "WZ3P96AJfEc", storyDate: "UNKNOWN", galleryTrack: "track_52" },
            { id: 54, title: "Normal?!", artist: "Ethel", videoId: "8GCXnOQI60g", storyDate: "UNKNOWN", galleryTrack: "track_54" },
            { id: 55, title: "This isn't therapy", artist: "Isla", videoId: "0tzOaukuBns", storyDate: "UNKNOWN", galleryTrack: "track_55" },
            { id: 56, title: "A Drop From the Forth", artist: "Isla", videoId: "6bwKDegeBHU", storyDate: "UNKNOWN", galleryTrack: "track_56" },
            { id: 57, title: "The Porcelain Lie", artist: "Isla", videoId: "GFkK21BdE9o", storyDate: "UNKNOWN", galleryTrack: "track_57" },
            { id: 58, title: "Memory under Water", artist: "Isla", videoId: "nk4Re7OjTTM", storyDate: "UNKNOWN", galleryTrack: "track_58" },
            { id: 59, title: "Raise The Fourth", artist: "Isla", videoId: "ey20cJsY82M", storyDate: "UNKNOWN", galleryTrack: "track_59" },
            { id: 60, title: "Raise The Fourth Version 2", artist: "Isla", videoId: "fNVKsxe_EcM", storyDate: "UNKNOWN", galleryTrack: "track_60" },
            { id: 61, title: "Intro to Shiny Headed Radio Man", artist: "Isla", videoId: "dK8mqLNRZ2Q", storyDate: "UNKNOWN", galleryTrack: "track_61" },
            { id: 62, title: "Shiny Headed Radio Man", artist: "Isla", videoId: "UFZeKCcSMoE", storyDate: "UNKNOWN", galleryTrack: "track_62" },
            { id: 63, title: "Stanmore Farewell", artist: "Isla", videoId: "-3m2_zUNBlo", storyDate: "UNKNOWN", galleryTrack: "track_63" },
            { id: 64, title: "Don't Wake Him Yet", artist: "Isla", videoId: "NwqHLFYR1mA", storyDate: "UNKNOWN", galleryTrack: "track_64" },
            { id: 65, title: "What You Don't See", artist: "Isla", videoId: "Y4VC6mh37NI", storyDate: "UNKNOWN", galleryTrack: "track_65" },
            { id: 66, title: "Melody of Normality (Live)", artist: "Isla", videoId: "a4TpIhna55k", storyDate: "UNKNOWN", galleryTrack: "track_66" },
            { id: 67, title: "Drop From the Fourth (Symphony)", artist: "Isla", videoId: "7UOZCk5vvbA", storyDate: "UNKNOWN", galleryTrack: "track_67" },
            { id: 68, title: "What you dont see (Symphony)", artist: "Isla", videoId: "hm2kp7LOhsg", storyDate: "UNKNOWN", galleryTrack: "track_68" },
            { id: 69, title: "Give it back", artist: "Isla", videoId: "Aw2ZAkxp6b0", storyDate: "UNKNOWN", galleryTrack: "track_69" },
            { id: 70, title: "What This Was Always For", artist: "Isla", videoId: "X9EUb1_QC9c", storyDate: "UNKNOWN", galleryTrack: "track_70" },
            { id: 71, title: "FIELD NOTES FROM THE LANGTANG TRAIL, 1966", artist: "UNKNOWN", videoId: "8nuKkf_oe1s", storyDate: "1966", galleryTrack: "track_71" }
        ];

        // --- GALLERY ENGINE (Image Slideshow) ---
        // Loads narrative images from gallery_map.json and crossfades them behind the fluid
        class GalleryEngine {
            constructor() {
                this.galleryMap = null;
                this.currentImages = [];
                this.currentIndex = 0;
                this.activeSlot = 'a';
                this.intervalId = null;
                this.imgA = document.getElementById('gallery-img-a');
                this.imgB = document.getElementById('gallery-img-b');
                this.container = document.getElementById('bg-gallery');
                this.onImageReady = null; // Callback for ColorExtractor
            }

            async loadMap() {
                try {
                    const resp = await fetch('library/char_ethel_media/gallery_map.json');
                    const rawMap = await resp.json();

                    // Transform remote GitHub Pages URLs to local relative paths.
                    // GitHub Pages 301-redirects case-mismatched URLs, stripping CORS headers.
                    // Local paths eliminate CORS entirely since images are co-located.
                    const REMOTE_BASE = /https:\/\/NJsalubrious\.github\.io\/pixelstortion-assets\/assets_for_ethel_songs\/images\//gi;
                    const LOCAL_BASE = 'library/char_ethel_media/images/';

                    this.galleryMap = {};
                    for (const [track, urls] of Object.entries(rawMap)) {
                        this.galleryMap[track] = urls.map(url => url.replace(REMOTE_BASE, LOCAL_BASE));
                    }

                    console.log('[Gallery] Map loaded:', Object.keys(this.galleryMap).length, 'tracks (local paths)');
                } catch (e) {
                    console.warn('[Gallery] Failed to load gallery_map.json:', e);
                }
            }

            loadTrack(galleryTrack) {
                // Aggressively clear any running interval before anything else
                this.stopCycling();
                this.currentIndex = 0;

                if (!galleryTrack || !this.galleryMap || !this.galleryMap[galleryTrack]) {
                    // No gallery for this track — hide the container entirely
                    this.currentImages = [];
                    this.container.style.opacity = '0';
                    // Remove active class from both slots so previous images don't linger
                    this.imgA.classList.remove('active');
                    this.imgB.classList.remove('active');
                    return;
                }

                this.currentImages = this.galleryMap[galleryTrack];
                this.container.style.opacity = '1';

                // Show the first image immediately
                if (this.currentImages.length > 0) {
                    this.showImage(this.currentImages[0]);
                }
            }

            showImage(url) {
                const target = this.activeSlot === 'a' ? this.imgA : this.imgB;
                const other = this.activeSlot === 'a' ? this.imgB : this.imgA;

                // CRITICAL: Set crossOrigin BEFORE src to avoid tainted canvas
                target.crossOrigin = 'Anonymous';
                target.onload = () => {
                    target.classList.add('active');
                    other.classList.remove('active');
                    this.activeSlot = this.activeSlot === 'a' ? 'b' : 'a';

                    // Notify the color extractor that a new image is ready
                    if (this.onImageReady) this.onImageReady(target);
                };
                target.onerror = () => {
                    console.warn('[Gallery] Failed to load image:', url);
                };
                target.src = url;
            }

            startCycling() {
                this.stopCycling();
                if (this.currentImages.length <= 1) return;

                this.intervalId = setInterval(() => {
                    this.currentIndex = (this.currentIndex + 1) % this.currentImages.length;
                    this.showImage(this.currentImages[this.currentIndex]);
                }, 6000);
            }

            stopCycling() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }
        }

        // --- COLOR EXTRACTOR (Shape & Color Hotspot Scanner) ---
        // Scans image for bright/colorful regions and uses those as fluid spawn points
        class ColorExtractor {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.width = 128;
                this.height = 128;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.hotspots = []; // Stores coordinates of bright/colorful pixels
            }

            extractFromImage(img) {
                try {
                    this.ctx.drawImage(img, 0, 0, this.width, this.height);
                    const data = this.ctx.getImageData(0, 0, this.width, this.height).data;
                    this.hotspots = [];

                    // Scan the image for non-dark areas to extract shape
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i] / 255;
                        let g = data[i + 1] / 255;
                        let b = data[i + 2] / 255;
                        let luminance = (r * 0.299 + g * 0.587 + b * 0.114);

                        // If it's bright or colorful enough, log it as a fluid spawn point
                        if (luminance > 0.15) {
                            let x = ((i / 4) % this.width) / this.width;
                            let y = Math.floor((i / 4) / this.width) / this.height;

                            // Boost saturation slightly for the mist effect
                            const max = Math.max(r, g, b);
                            if (max > 0 && max < 0.8) {
                                const boost = 0.8 / max;
                                r *= boost; g *= boost; b *= boost;
                            }

                            this.hotspots.push({ x: x, y: 1.0 - y, r, g, b }); // Y inverted for WebGL
                        }
                    }
                    console.log(`[Color] Mapped ${this.hotspots.length} emission points.`);
                } catch (e) {
                    console.warn('[Color] Extraction failed:', e.message);
                    this.hotspots = [];
                }
            }

            getRandomHotspot() {
                if (this.hotspots.length === 0) {
                    return { x: 0.2 + Math.random() * 0.6, y: 0.2 + Math.random() * 0.6, r: 0, g: 0.6, b: 0.3 };
                }
                return this.hotspots[Math.floor(Math.random() * this.hotspots.length)];
            }
        }

        // --- LYRICS ARCHIVE ---
        const LYRICS_ARCHIVE = {
            // "track_06": `Polished vomit\nNapkin smile\n...`,
        };

        // --- DEBUG FLAGS ---
        const URL_PARAMS = new URLSearchParams(window.location.search);
        const DEBUG_MODE = URL_PARAMS.has('debug');
        const MUTE_WHISPERS = URL_PARAMS.has('muteWhispers');

        // --- LYRIC FEEL ENGINE ---
        class LyricFeelEngine {
            constructor() {
                this.curve = [];
                this.durationS = 0;
                this.artist = '';
                this.lex = {
                    violence: ['blood', 'kill', 'hit', 'break', 'smash', 'crash', 'burn', 'cut', 'stab', 'hurt', 'dead', 'die', 'scream'],
                    rupture: ['vomit', 'skin', 'body', 'bone', 'flesh', 'teeth', 'tongue', 'swallow', 'throat', 'naked', 'bleed', 'rip', 'tear', 'spit'],
                    control: ['mine', 'own', 'obey', 'allow', 'permit', 'correct', 'manage', 'silence', 'quiet', 'behave', 'comply', 'rule', 'order'],
                    pressure: ['hold', 'tight', 'grip', 'weight', 'crush', 'press', 'suffocate', 'drown', 'trap', 'cage', 'box', 'wall', 'lock'],
                    beauty: ['white', 'pretty', 'clean', 'smile', 'gentle', 'soft', 'light', 'flower', 'dress', 'wedding', 'dance', 'love', 'kiss'],
                    rot: ['vomit', 'stain', 'rot', 'mould', 'rust', 'waste', 'decay', 'filth', 'dirt', 'broken', 'ruin', 'ash', 'dust']
                };
            }
            _hash(s) { let h = 0; for (let i = 0; i < s.length; i++) h = ((h << 5) - h + s.charCodeAt(i)) | 0; return Math.abs(h); }
            _rng(seed) { let s = seed; return () => { s = (s * 16807) % 2147483647; return s / 2147483647; }; }
            _scoreLine(line) {
                const w = line.toLowerCase().split(/\s+/); let int = 0, cold = 0, rupt = 0, beau = 0, rot = 0;
                for (const x of w) {
                    if (this.lex.violence.some(k => x.includes(k))) int += 0.3;
                    if (this.lex.rupture.some(k => x.includes(k))) { rupt += 0.35; int += 0.15; }
                    if (this.lex.control.some(k => x.includes(k))) { cold += 0.4; int += 0.1; }
                    if (this.lex.pressure.some(k => x.includes(k))) int += 0.25;
                    if (this.lex.beauty.some(k => x.includes(k))) beau++;
                    if (this.lex.rot.some(k => x.includes(k))) rot++;
                }
                const contra = Math.min(beau, rot);
                if (contra > 0) { int += contra * 0.4; rupt += contra * 0.3; }
                return { intensity: Math.min(1, int), coldness: Math.min(1, cold), rupture: Math.min(1, rupt) };
            }
            build(track, dur) {
                this.durationS = Math.max(1, dur); this.artist = track.artist || '';
                const lyr = LYRICS_ARCHIVE[track.galleryTrack], n = Math.ceil(this.durationS);
                this.curve = new Array(n);
                if (lyr && lyr.trim().length > 10) this._fromLyrics(lyr, n, track); else this._fromHash(track, n);
                // Smooth
                const sm = [];
                for (let i = 0; i < n; i++) {
                    const p = this.curve[Math.max(0, i - 1)], c = this.curve[i], nx = this.curve[Math.min(n - 1, i + 1)];
                    sm[i] = {
                        intensity: (p.intensity + c.intensity + nx.intensity) / 3, volatility: 0,
                        coldness: (p.coldness + c.coldness + nx.coldness) / 3, rupture: (p.rupture + c.rupture + nx.rupture) / 3
                    };
                }
                this.curve = sm;
                // Volatility
                for (let i = 1; i < n - 1; i++) {
                    const d1 = this.curve[i].intensity - this.curve[i - 1].intensity;
                    const d2 = this.curve[i + 1].intensity - this.curve[i].intensity;
                    this.curve[i].volatility = Math.min(1, Math.abs(d1 - d2) * 3);
                }
                if (n > 0) this.curve[0].volatility = 0;
                if (n > 1) this.curve[n - 1].volatility = this.curve[n - 2].volatility;
                console.log(`[LyricFeel] Built: ${n}s, ${this.artist}, lyrics=${!!lyr}`);
            }
            _fromLyrics(lyr, n, track) {
                const lines = lyr.split('\n').filter(l => l.trim()), spl = Math.max(1, n / lines.length);
                const am = { intensity: 1, coldness: 1, rupture: 1 };
                if (this.artist === 'Isla') { am.rupture = 1.5; am.intensity = 1.2; }
                else if (this.artist === 'Dominic') { am.coldness = 1.8; am.intensity = 0.8; }
                else if (this.artist === 'Ethel') am.intensity = 1.3;
                const macro = t => t < 0.1 ? 0.3 + t * 4 : t < 0.4 ? 0.7 : t < 0.8 ? 0.7 + (t - 0.4) * 0.75 : 1 - (t - 0.8) * 3;
                for (let s = 0; s < n; s++) {
                    const li = Math.min(lines.length - 1, Math.floor(s / spl)), sc = this._scoreLine(lines[li]);
                    const m = macro(s / n), ph = (s % spl) / spl, env = ph < 0.15 ? ph / 0.15 : ph < 0.6 ? 1 : 1 - (ph - 0.6) / 0.4;
                    this.curve[s] = {
                        intensity: Math.min(1, sc.intensity * am.intensity * m * env), volatility: 0,
                        coldness: Math.min(1, sc.coldness * am.coldness * m), rupture: Math.min(1, sc.rupture * am.rupture * m * env)
                    };
                }
            }
            _fromHash(track, n) {
                const seed = this._hash(track.videoId + track.title + (track.storyDate || '')), rng = this._rng(seed);
                let bc = 0, br = 0, bi = 0.3;
                if (this.artist === 'Dominic') { bc = 0.5; bi = 0.25; }
                else if (this.artist === 'Isla') { br = 0.4; bi = 0.4; }
                else if (this.artist === 'Ethel') bi = 0.35;
                const pks = []; for (let p = 0; p < 3 + Math.floor(rng() * 5); p++) pks.push({ pos: rng(), str: 0.3 + rng() * 0.7, w: 0.03 + rng() * 0.08 });
                const bf = 1.5 + rng() * 1.5;
                for (let s = 0; s < n; s++) {
                    const t = s / n, m = t < 0.1 ? t * 6 : t > 0.9 ? (1 - t) * 6 : 0.6 + 0.4 * Math.sin(t * Math.PI);
                    let pv = 0; for (const pk of pks) { const d = Math.abs(t - pk.pos); if (d < pk.w) pv += pk.str * (1 - d / pk.w); }
                    const mb = 0.1 * Math.pow(Math.sin(s * bf), 4);
                    this.curve[s] = {
                        intensity: Math.min(1, (bi + pv * 0.6 + mb) * m), volatility: 0,
                        coldness: Math.min(1, bc * m), rupture: Math.min(1, (br + pv * 0.3) * m)
                    };
                }
            }
            sample(tS) {
                if (!this.curve.length) return { intensity: 0.2, volatility: 0, coldness: 0, rupture: 0 };
                return this.curve[Math.min(this.curve.length - 1, Math.max(0, Math.floor(tS)))];
            }
        }

        // --- PULSE ENGINE (replaces BeatEngine) ---
        class PulseEngine {
            constructor(fl) { this.fluid = fl; this.active = false; this.interval = null; this.lastT = 0; this.artist = ''; }
            setTrack(t) { let s = 0; const str = (t.videoId || '') + (t.title || ''); for (let i = 0; i < str.length; i++) s = ((s << 5) - s + str.charCodeAt(i)) | 0; this.trackSeed = Math.abs(s); this.artist = t.artist || ''; }
            start() { this.active = true; this.loop(); }
            stop() { this.active = false; if (this.interval) clearTimeout(this.interval); }
            loop() {
                if (!this.active) return;
                const feel = lyricFeelEngine ? lyricFeelEngine.sample(jukebox.player?.getCurrentTime?.() || 0) : { intensity: 0.2, volatility: 0 };
                let bMs, v;
                if (this.artist === 'Dominic') { bMs = 800; v = 50; }
                else if (this.artist === 'Isla') { bMs = 300 + (1 - feel.intensity) * 500; v = 300; }
                else if (this.artist === 'Ethel') { bMs = 500 + (1 - feel.intensity) * 400; v = 100; }
                else { bMs = 600; v = 200; }
                const ms = Math.max(100, bMs - feel.intensity * 300 + (Math.random() - 0.5) * v);
                this.interval = setTimeout(() => { this.pulse(feel); this.loop(); }, ms);
            }
            pulse(feel) {
                if (!colorExtractor || !this.fluid) return;
                const cnt = feel.intensity > 0.6 ? 5 : feel.intensity > 0.3 ? 3 : 2;
                const mag = 200 + feel.intensity * 800 + feel.volatility * 400;
                for (let i = 0; i < cnt; i++) {
                    const sp = colorExtractor.getRandomHotspot();
                    this.fluid.splatStack.push({
                        x: sp.x, y: sp.y,
                        dx: (Math.random() - 0.5) * mag, dy: Math.random() * mag - mag * 0.2,
                        color: { r: sp.r * (0.3 + feel.intensity * 0.5), g: sp.g * (0.3 + feel.intensity * 0.5), b: sp.b * (0.3 + feel.intensity * 0.5) }
                    });
                }
                if (window.FLUID_CONFIG && Date.now() - this.lastT > 100) {
                    FLUID_CONFIG.CURL = Math.max(0.3, FLUID_CONFIG.CURL + (feel.volatility - 0.5) * 0.3);
                    this.lastT = Date.now();
                }
            }
        }

        // --- WHISPER ENGINE ---
        class WhisperEngine {
            constructor() {
                this.fgEl = document.getElementById('whisper-fg');
                this.bgEl = document.getElementById('whisper-bg');
                this.lastFire = 0; this.cooldown = 12000; this.count = 0; this.max = 8; this.prevInt = 0; this.active = false;
                this.phrases = {
                    Dominic: {
                        fg: ["YOU AGREED TO THIS", "I NEVER RAISED MY VOICE", "SHE WAS ALWAYS DIFFICULT", "THIS IS WHAT LOVE LOOKS LIKE", "I'M THE ONLY ONE WHO STAYED"],
                        bg: ["(why won't you leave?)", "(you know what you did)", "(it was never that bad)", "(she made me)", "(nobody asked)"]
                    },
                    Isla: {
                        fg: ["NOBODY CHECKED", "THE ROOM WENT QUIET", "SHE SAID IT SO CALMLY", "POLISHED VOMIT", "THE DRESS WAS WHITE"],
                        bg: ["(who cleans this up?)", "(was it always like this?)", "(she smiled through it)", "(don't look away)", "(you saw it too)"]
                    },
                    Ethel: {
                        fg: ["I BUILT A BOX", "THE CRASH NEVER STOPPED", "EVERYTHING IS EVIDENCE", "HOLD THE LINE", "I WON'T BREAK WHERE OTHERS END"],
                        bg: ["(how long can you hold?)", "(the pressure doesn't stop)", "(you're still here)", "(don't look away)", "(it gets heavier)"]
                    },
                    System: {
                        fg: ["RECORD ACCESSED", "TIMELINE DEVIATION DETECTED", "MEMORY INTEGRITY: PARTIAL", "NARRATIVE UNDER REVIEW", "EVIDENCE RECLASSIFIED"],
                        bg: ["(this was already recorded)", "(you can't unsee this)", "(the system remembers)", "(pause doesn't stop consequence)", "(seek detected)"]
                    }
                };
            }
            reset() { this.count = 0; this.prevInt = 0; }
            start() { this.active = true; }
            stop() { this.active = false; this.hide(); }
            update(feel, artist, brState) {
                if (!this.active || MUTE_WHISPERS || this.count >= this.max) return;
                if (Date.now() - this.lastFire < this.cooldown) return;
                const rising = this.prevInt < 0.55 && feel.intensity >= 0.55;
                this.prevInt = feel.intensity;
                if (rising || (brState && brState !== 'LISTENING' && Math.random() < 0.1)) this.fire(artist, brState);
            }
            fire(artist, brState) {
                const pool = this.phrases[artist] || this.phrases.System, sys = this.phrases.System;
                const fgP = Math.random() < 0.3 ? sys.fg : pool.fg;
                const fg = fgP[Math.floor(Math.random() * fgP.length)];
                let bg;
                if (brState && brState !== 'LISTENING') {
                    const hints = {
                        AVOIDING: "(why do you keep skipping?)", CONTROLLING: "(why do you keep seeking?)",
                        FREEZING: "(what stopped you?)", PRESSURE: "(you're still inside it)", NEGOTIATING: "(you're trying to bargain)"
                    };
                    bg = hints[brState] || pool.bg[Math.floor(Math.random() * pool.bg.length)];
                } else bg = pool.bg[Math.floor(Math.random() * pool.bg.length)];
                this.show(fg, bg); this.count++; this.lastFire = Date.now();
            }
            show(fg, bg) {
                if (!this.fgEl || !this.bgEl) return;
                const ox = 30 + Math.random() * 40, oy = 30 + Math.random() * 40;
                this.fgEl.style.left = ox + '%'; this.fgEl.style.top = oy + '%'; this.fgEl.style.transform = 'translate(-50%,-50%)';
                this.bgEl.style.left = (ox + (Math.random() - 0.5) * 10) + '%'; this.bgEl.style.top = (oy + 5 + Math.random() * 5) + '%'; this.bgEl.style.transform = 'translate(-50%,-50%)';
                this.fgEl.innerText = fg; this.bgEl.innerText = bg;
                const fi = 250 + Math.random() * 200;
                this.fgEl.style.transition = `opacity ${fi}ms ease`; this.bgEl.style.transition = `opacity ${fi + 200}ms ease`;
                this.fgEl.style.opacity = '1'; setTimeout(() => { this.bgEl.style.opacity = '1'; }, 150);
                setTimeout(() => { this.hide(450 + Math.random() * 450); }, fi + 900 + Math.random() * 600);
            }
            hide(ms = 500) {
                if (!this.fgEl || !this.bgEl) return;
                this.fgEl.style.transition = `opacity ${ms}ms ease`; this.bgEl.style.transition = `opacity ${ms}ms ease`;
                this.fgEl.style.opacity = '0'; this.bgEl.style.opacity = '0';
            }
        }

        // --- BRANCH ENGINE ---
        class BranchEngine {
            constructor() {
                this.events = []; this.windowMs = 15000; this.state = 'LISTENING'; this.prevState = 'LISTENING';
                this.evalInterval = null; this.evidenceEl = document.getElementById('evidence-tag');
                this.statusEl = document.getElementById('status-indicator');
                this.totalListen = 0; this.highIntTime = 0;
            }
            logEvent(type) { this.events.push({ type, time: Date.now() }); }
            start() { this.evalInterval = setInterval(() => this.evaluate(), 1200); }
            stop() { if (this.evalInterval) clearInterval(this.evalInterval); }
            reset() { this.events = []; this.state = 'LISTENING'; this.prevState = 'LISTENING'; this.totalListen = 0; this.highIntTime = 0; }
            updateExposure(feel, dt) { this.totalListen += dt; if (feel.intensity > 0.6) this.highIntTime += dt; }
            evaluate() {
                const now = Date.now(), rec = this.events.filter(e => now - e.time < this.windowMs);
                const sk = rec.filter(e => e.type === 'skip').length, se = rec.filter(e => e.type === 'seek').length, pa = rec.filter(e => e.type === 'pause').length;
                const pr = this.totalListen > 10 ? this.highIntTime / this.totalListen : 0;
                this.prevState = this.state;
                if (sk >= 4) this.state = 'AVOIDING';
                else if (se >= 3 && sk < 2) this.state = 'NEGOTIATING';
                else if (se >= 3) this.state = 'CONTROLLING';
                else if (pa >= 3) this.state = 'FREEZING';
                else if (pr > 0.5) this.state = 'PRESSURE';
                else this.state = 'LISTENING';
                this.updateEvidence();
                if (this.state !== this.prevState) { console.log(`[Branch] ${this.prevState} → ${this.state}`); this.applyWorld(); }
                return this.state !== this.prevState;
            }
            updateEvidence() {
                if (!this.evidenceEl) return;
                const m = {
                    LISTENING: { c: 'PENDING', m: 'STABLE', n: 'BASELINE' },
                    AVOIDING: { c: 'SUPPRESSED', m: 'FRACTURED (AVOIDANCE)', n: 'LOW' },
                    CONTROLLING: { c: 'DISPUTED', m: 'RESEQUENCED (INTERFERENCE)', n: 'LOW' },
                    NEGOTIATING: { c: 'CONDITIONAL', m: 'UNDER NEGOTIATION', n: 'UNSTABLE' },
                    FREEZING: { c: 'SUSPENDED', m: 'FROZEN (PROCESSING FAILURE)', n: 'INTERRUPTED' },
                    PRESSURE: { c: 'ADMISSIBLE', m: 'INTACT', n: 'HIGH' }
                };
                const e = m[this.state] || m.LISTENING;
                this.evidenceEl.innerHTML = `EVIDENCE CLASS: ${e.c}<br>MEMORY INTEGRITY: ${e.m}<br>NARRATIVE CONFIDENCE: ${e.n}`;
            }
            applyWorld() {
                if (window.FLUID_CONFIG) {
                    const p = {
                        AVOIDING: { CURL: 0.8, SPLAT_RADIUS: 0.4, DENSITY_DISSIPATION: 0.997 },
                        CONTROLLING: { CURL: 0.3, SPLAT_RADIUS: 0.5, DENSITY_DISSIPATION: 0.998 },
                        NEGOTIATING: { CURL: 2, SPLAT_RADIUS: 0.8, DENSITY_DISSIPATION: 0.993 },
                        FREEZING: { CURL: 0.1, SPLAT_RADIUS: 0.3, DENSITY_DISSIPATION: 0.999 },
                        PRESSURE: { CURL: 5, SPLAT_RADIUS: 1.0, DENSITY_DISSIPATION: 0.988 }
                    };
                    const pr = p[this.state]; if (pr) { FLUID_CONFIG.CURL = pr.CURL; FLUID_CONFIG.SPLAT_RADIUS = pr.SPLAT_RADIUS; FLUID_CONFIG.DENSITY_DISSIPATION = pr.DENSITY_DISSIPATION; }
                }
                if (this.statusEl && this.state !== 'LISTENING') {
                    const ot = this.statusEl.innerText, oc = this.statusEl.style.color;
                    const dc = { AVOIDING: '#ff4444', CONTROLLING: '#ff8800', NEGOTIATING: '#ffcc00', FREEZING: '#6666ff', PRESSURE: '#ff0066' };
                    this.statusEl.innerText = this.state; this.statusEl.style.color = dc[this.state] || '#00ff41';
                    setTimeout(() => { if (this.statusEl) { this.statusEl.innerText = ot; this.statusEl.style.color = oc; } }, 6000);
                }
                const t = document.getElementById('track-title'); if (t) { t.classList.add('glitch-pulse'); setTimeout(() => t.classList.remove('glitch-pulse'), 200); }
            }
        }

        // --- JUKEBOX CONTROLLER (v2) ---
        class Jukebox {
            constructor() {
                this.player = null;
                this.currentTrackIndex = -1;
                this.playedHistory = [];
                this.isPlaying = false;
                this.pulseEngine = null;
                this.lastProgressTime = 0;
                this.idleTimer = null;
            }

            init(fluidEngine) {
                this.pulseEngine = new PulseEngine(fluidEngine);
            }

            loadRandomTrack() {
                let newIndex;
                do { newIndex = Math.floor(Math.random() * SONG_ARCHIVE.length); }
                while (newIndex === this.currentTrackIndex && SONG_ARCHIVE.length > 1);
                this.loadTrack(newIndex);
            }

            loadTrack(index) {
                this.currentTrackIndex = index;
                const track = SONG_ARCHIVE[index];

                // UI Update
                document.getElementById('track-title').innerText = track.title;
                document.getElementById('track-artist').innerText = track.artist;
                document.getElementById('track-date').innerText = track.storyDate || '';
                document.getElementById('status-indicator').innerText = 'BUFFERING';

                // Apply narrative fluid identity + temporal weight
                this.applyArtistProfile(track.artist);
                this.applyTemporalWeight(track.storyDate);

                // Gallery
                if (galleryEngine) galleryEngine.loadTrack(track.galleryTrack);

                // v2: Set pulse track seed + reset engines
                if (this.pulseEngine) this.pulseEngine.setTrack(track);
                if (whisperEngine) whisperEngine.reset();
                if (branchEngine) branchEngine.reset();

                // Load Video
                if (this.player && this.player.loadVideoById) {
                    this.player.loadVideoById(track.videoId);
                }
            }

            togglePlay() {
                if (!this.player) return;
                const state = this.player.getPlayerState();
                if (state === 1) this.player.pauseVideo();
                else this.player.playVideo();
            }

            next() {
                if (branchEngine) branchEngine.logEvent('skip');
                this.loadRandomTrack();
            }

            prev() {
                if (branchEngine) branchEngine.logEvent('skip');
                this.loadRandomTrack();
            }

            seek(event) {
                if (!this.player) return;
                if (branchEngine) branchEngine.logEvent('seek');
                const container = document.querySelector('.progress-container');
                const rect = container.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, clickX / rect.width));
                this.player.seekTo(this.player.getDuration() * percent, true);
            }

            onStateChange(event) {
                const status = document.getElementById('status-indicator');
                const playIcon = document.getElementById('play-icon');

                if (event.data === YT.PlayerState.PLAYING) {
                    this.isPlaying = true;
                    status.innerText = 'PLAYING';
                    status.style.color = '#00ff41';
                    playIcon.innerText = 'pause';
                    if (this.pulseEngine) this.pulseEngine.start();
                    if (galleryEngine) galleryEngine.startCycling();
                    if (whisperEngine) whisperEngine.start();
                    if (branchEngine) branchEngine.start();
                    if (this.idleTimer) { clearInterval(this.idleTimer); this.idleTimer = null; }

                    // v2: Build lyric curve on first play (need duration)
                    if (lyricFeelEngine && this.player) {
                        const dur = this.player.getDuration();
                        const track = SONG_ARCHIVE[this.currentTrackIndex];
                        if (dur > 0 && track) lyricFeelEngine.build(track, dur);
                    }

                    // Micro-corruption glitch
                    const titleEl = document.getElementById('track-title');
                    titleEl.classList.add('glitch-pulse');
                    setTimeout(() => titleEl.classList.remove('glitch-pulse'), 200);
                }
                else if (event.data === YT.PlayerState.PAUSED) {
                    this.isPlaying = false;
                    status.innerText = 'PAUSED';
                    status.style.color = 'orange';
                    playIcon.innerText = 'play_arrow';
                    if (this.pulseEngine) this.pulseEngine.stop();
                    if (galleryEngine) galleryEngine.stopCycling();
                    if (branchEngine) branchEngine.logEvent('pause');

                    // v2: Surveillance idle mode
                    this.startIdleMode();
                }
                else if (event.data === YT.PlayerState.ENDED) {
                    this.isPlaying = false;
                    status.innerText = 'LOADING NEXT...';
                    if (this.pulseEngine) this.pulseEngine.stop();
                    if (whisperEngine) whisperEngine.stop();
                    if (galleryEngine) galleryEngine.stopCycling();
                    this.next();
                }
            }

            updateProgress() {
                if (!this.player || !this.isPlaying) return;
                const curr = this.player.getCurrentTime();
                const total = this.player.getDuration();
                if (total <= 0) return;

                const pct = (curr / total) * 100;
                const bar = document.getElementById('progress-bar');
                bar.style.width = `${pct}%`;
                document.getElementById('curr-time').innerText = this.formatTime(curr);
                document.getElementById('total-time').innerText = this.formatTime(total);

                // Signal jitter
                if (Math.random() < 0.02) {
                    bar.style.filter = 'brightness(1.8)';
                    setTimeout(() => { bar.style.filter = 'none'; }, 100);
                }

                // v2: Feed engines
                const feel = lyricFeelEngine ? lyricFeelEngine.sample(curr) : { intensity: 0.2, volatility: 0, coldness: 0, rupture: 0 };
                const dt = curr - this.lastProgressTime;
                this.lastProgressTime = curr;
                const track = SONG_ARCHIVE[this.currentTrackIndex];
                const artist = track ? track.artist : '';

                if (branchEngine) branchEngine.updateExposure(feel, Math.abs(dt));
                if (whisperEngine) whisperEngine.update(feel, artist, branchEngine ? branchEngine.state : 'LISTENING');

                // v2: Debug overlay
                if (DEBUG_MODE) this.updateDebug(feel);
            }

            updateDebug(feel) {
                const dbg = document.getElementById('debug-overlay');
                if (!dbg) return;
                dbg.style.display = 'block';
                dbg.innerHTML = `INT: ${feel.intensity.toFixed(2)} | VOL: ${feel.volatility.toFixed(2)}<br>` +
                    `COLD: ${feel.coldness.toFixed(2)} | RUPT: ${feel.rupture.toFixed(2)}<br>` +
                    `BRANCH: ${branchEngine ? branchEngine.state : '-'}<br>` +
                    `WHISPERS: ${whisperEngine ? whisperEngine.count : '-'}/${whisperEngine ? whisperEngine.max : '-'}`;
            }

            startIdleMode() {
                // Surveillance ambient when paused
                if (this.idleTimer) return;
                this.idleTimer = setInterval(() => {
                    if (this.isPlaying) { clearInterval(this.idleTimer); this.idleTimer = null; return; }
                    if (whisperEngine && !MUTE_WHISPERS && Math.random() < 0.08) {
                        whisperEngine.show('PAUSE DOESN\'T STOP CONSEQUENCE', '(the system remembers)');
                        whisperEngine.count++; whisperEngine.lastFire = Date.now();
                    }
                    // Low idle splat
                    if (this.pulseEngine && this.pulseEngine.fluid && colorExtractor) {
                        const sp = colorExtractor.getRandomHotspot();
                        this.pulseEngine.fluid.splatStack.push({
                            x: sp.x, y: sp.y,
                            dx: (Math.random() - 0.5) * 80, dy: (Math.random() - 0.5) * 80,
                            color: { r: sp.r * 0.15, g: sp.g * 0.15, b: sp.b * 0.15 }
                        });
                    }
                }, 4000);
            }

            formatTime(s) {
                const m = Math.floor(s / 60);
                const secs = Math.floor(s % 60);
                return `${m}:${secs < 10 ? '0' : ''}${secs}`;
            }

            onError(event) {
                console.warn('YouTube Player Error:', event.data);
                const status = document.getElementById('status-indicator');
                if (status) { status.innerText = 'SIGNAL LOST'; status.style.color = 'red'; }
                if (this.pulseEngine && !this.pulseEngine.active) {
                    console.log('Activating Visual Fallback Mode');
                    this.pulseEngine.start();
                }
            }

            applyArtistProfile(artist) {
                if (!window.FLUID_CONFIG) return;
                if (artist === 'Ethel') { FLUID_CONFIG.CURL = 1; FLUID_CONFIG.SPLAT_RADIUS = 0.6; FLUID_CONFIG.DENSITY_DISSIPATION = 0.994; FLUID_CONFIG.VELOCITY_DISSIPATION = 0.99; }
                else if (artist === 'Isla') { FLUID_CONFIG.CURL = 6; FLUID_CONFIG.SPLAT_RADIUS = 1.2; FLUID_CONFIG.DENSITY_DISSIPATION = 0.985; FLUID_CONFIG.VELOCITY_DISSIPATION = 0.97; }
                else if (artist === 'Dominic') { FLUID_CONFIG.CURL = 0.5; FLUID_CONFIG.SPLAT_RADIUS = 0.4; FLUID_CONFIG.DENSITY_DISSIPATION = 0.998; FLUID_CONFIG.VELOCITY_DISSIPATION = 0.995; }
                else if (artist === 'Kinley') { FLUID_CONFIG.CURL = 3; FLUID_CONFIG.SPLAT_RADIUS = 0.7; FLUID_CONFIG.DENSITY_DISSIPATION = 0.993; FLUID_CONFIG.VELOCITY_DISSIPATION = 0.98; }
                else { FLUID_CONFIG.CURL = 2; FLUID_CONFIG.SPLAT_RADIUS = 0.9; FLUID_CONFIG.DENSITY_DISSIPATION = 0.992; FLUID_CONFIG.VELOCITY_DISSIPATION = 0.985; }
            }

            applyTemporalWeight(storyDate) {
                const status = document.getElementById('status-indicator');
                if (!storyDate || !status) return;
                const d = storyDate.toUpperCase();
                if (d.includes('PRISON')) status.style.color = '#8800ff';
                else if (d.includes('CRASH')) status.style.color = '#ff2200';
                else if (d.includes('LEAK')) status.style.color = '#00aaff';
                else if (d.includes('TRIAL')) status.style.color = '#ffaa00';
                else if (d.includes('ESCAPE')) status.style.color = '#ff00ff';
                else if (d.includes('WEDDING')) status.style.color = '#ff6699';
                else if (d.includes('MOSMAN')) status.style.color = '#44ffaa';
                else if (d.includes('ARCHIVE')) status.style.color = '#666666';
            }
        }

        // --- INITIALIZATION (v2) ---
        let fluid;
        let galleryEngine;
        let colorExtractor;
        let lyricFeelEngine;
        let whisperEngine;
        let branchEngine;
        const jukebox = new Jukebox();

        function startSystem() {
            console.log('[JB] startSystem() called');

            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => overlay.remove(), 500);

            const canvasEl = document.getElementById('fluid-canvas');
            if (!canvasEl) { console.error('[JB] FATAL: #fluid-canvas not found!'); return; }

            if (typeof FluidSimulator === 'undefined') {
                console.error('[JB] FATAL: FluidSimulator not loaded!');
                const ctx = canvasEl.getContext('2d');
                if (ctx) { canvasEl.width = window.innerWidth; canvasEl.height = window.innerHeight; ctx.fillStyle = '#00ff41'; ctx.fillRect(0, 0, canvasEl.width, canvasEl.height); ctx.fillStyle = '#000'; ctx.font = '48px monospace'; ctx.fillText('FLUID ENGINE FAILED', 50, 100); }
                return;
            }

            try { fluid = new FluidSimulator(canvasEl, null); }
            catch (e) { console.error('[JB] FluidSimulator THREW:', e); return; }
            if (!fluid || !fluid.gl) { console.error('[JB] FATAL: gl context null!'); return; }

            // Gallery & Color
            galleryEngine = new GalleryEngine();
            colorExtractor = new ColorExtractor();
            galleryEngine.onImageReady = (img) => colorExtractor.extractFromImage(img);
            galleryEngine.loadMap();

            // v2: Init new engines
            lyricFeelEngine = new LyricFeelEngine();
            whisperEngine = new WhisperEngine();
            branchEngine = new BranchEngine();

            // Mist config
            if (window.FLUID_CONFIG) {
                FLUID_CONFIG.DENSITY_DISSIPATION = 0.992;
                FLUID_CONFIG.VELOCITY_DISSIPATION = 0.985;
                FLUID_CONFIG.SPLAT_RADIUS = 0.9;
                FLUID_CONFIG.CURL = 2;
            }

            // Init Jukebox (uses PulseEngine instead of BeatEngine)
            jukebox.init(fluid);

            // Initial splats
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                fluid.splatStack.push({
                    x: 0.5 + Math.cos(angle) * 0.1, y: 0.5 + Math.sin(angle) * 0.1,
                    dx: Math.cos(angle) * 4000, dy: Math.sin(angle) * 4000, color: { r: 0, g: 1, b: 0.25 }
                });
            }
            jukebox.pulseEngine.start();
            console.log('[JB] PulseEngine started');

            // Debug overlay visibility
            if (DEBUG_MODE) {
                const dbg = document.getElementById('debug-overlay');
                if (dbg) dbg.style.display = 'block';
            }

            // Progress loop
            setInterval(() => jukebox.updateProgress(), 1000);

            // First track
            if (jukebox.player) jukebox.loadRandomTrack();
            else setTimeout(() => jukebox.loadRandomTrack(), 1000);

            console.log('[JB] startSystem() complete (v2)');
        }

        // Load YouTube API Immediately on Page Load
        function onYouTubeIframeAPIReady() {
            jukebox.player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'playsinline': 1,
                    'controls': 0,
                    'disablekb': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': (e) => jukebox.onStateChange(e),
                    'onError': (e) => jukebox.onError(e)
                }
            });
        }

        function onPlayerReady(event) {
            console.log("Player Ready - Waiting for User Command");

            // PHASE 5: Cinematic boot sequence — feels like accessing a restricted archive
            const loadingText = document.getElementById('loading-text');
            const initBtn = document.getElementById('init-btn');

            if (loadingText && initBtn) {
                const bootMessages = [
                    "CHECKING MEMORY BLOCKS...",
                    "VERIFYING ARCHIVE INTEGRITY...",
                    "AUTHENTICATING NARRATIVE HASH...",
                    "SCANNING TIMELINE NODES...",
                    "UPLINK ESTABLISHED."
                ];

                let i = 0;
                const bootInterval = setInterval(() => {
                    loadingText.innerText = bootMessages[i];
                    i++;
                    if (i >= bootMessages.length) {
                        clearInterval(bootInterval);
                        setTimeout(() => {
                            loadingText.style.display = 'none';
                            initBtn.style.display = 'block';
                        }, 600);
                    }
                }, 800);
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // --- PHASE 6: HIDDEN ARCHIVE MODE ---
        // 5 rapid clicks on track title reveals the system's true nature
        (function initArchiveMode() {
            let clickCount = 0;
            let clickTimer;
            let archiveActive = false;

            document.getElementById('track-title').addEventListener('click', () => {
                clickCount++;
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => clickCount = 0, 1000);

                if (clickCount >= 5) {
                    clickCount = 0;
                    archiveActive = !archiveActive;

                    if (archiveActive) {
                        activateArchiveMode();
                    } else {
                        deactivateArchiveMode();
                    }
                }
            });
        })();

        function activateArchiveMode() {
            document.body.classList.add('archive-mode');
            document.getElementById('status-indicator').innerText = 'ARCHIVE MODE';
            document.getElementById('status-indicator').style.color = '#ff0000';
            const label = document.getElementById('catalogue-label');
            if (label) label.innerText = 'MODE: FULL ARCHIVE ACCESS // CLEARANCE: UNRESTRICTED';
            console.log('[ARCHIVE] Mode activated — all records exposed');
        }

        function deactivateArchiveMode() {
            document.body.classList.remove('archive-mode');
            document.getElementById('status-indicator').innerText = 'PLAYING';
            document.getElementById('status-indicator').style.color = '#00ff41';
            const label = document.getElementById('catalogue-label');
            if (label) label.innerText = 'Catalogue: 50 Tracks // Mode: Random Access';
            console.log('[ARCHIVE] Mode deactivated — returning to standard access');
        }

    </script>
</body>

</html>