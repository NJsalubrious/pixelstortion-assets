<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PIXELSTORTION // JUKEBOX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0"
        rel="stylesheet" />

    <style>
        :root {
            --neon-green: #00ff41;
            --fire-orange: #ff4500;
            --void: #050505;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void);
            overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
            cursor: crosshair;
        }

        /* --- VISUAL LAYERS --- */

        /* Layer 0: Narrative Gallery (behind everything) */
        #bg-gallery {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
            transition: opacity 0.8s ease;
        }

        .gallery-img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        .gallery-img.active {
            opacity: 0.4;
        }

        /* Layer 1: Fluid Canvas (screen blend drops out black) */
        #fluid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            mix-blend-mode: screen;
        }

        .scanlines {
            position: fixed;
            inset: 0;
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.2) 50%,
                    rgba(0, 0, 0, 0.6) 100%);
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
            opacity: 0.7;
        }

        /* Layer 5: Vignette — heavy, frames the narrative images into the void */
        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(5, 5, 5, 0.6) 60%, #050505 85%);
            z-index: 5;
            pointer-events: none;
        }

        /* --- UI LAYERS --- */
        #ui-layer {
            position: fixed;
            inset: 0;
            z-index: 20;
            pointer-events: none;
            /* Let clicks pass to fluid */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .interactive {
            pointer-events: auto;
        }

        /* --- TYPOGRAPHY --- */
        .glitch-text {
            font-family: 'Space Grotesk', sans-serif;
            text-transform: uppercase;
            position: relative;
            color: white;
            mix-blend-mode: difference;
        }

        .font-mono-custom {
            font-family: 'Courier Prime', monospace;
        }

        /* --- CONTROLS --- */
        .control-btn {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .control-btn:hover {
            border-color: var(--neon-green);
            color: var(--neon-green);
            transform: scale(1.1);
            background: rgba(0, 20, 0, 0.6);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* --- PROGRESS BAR --- */
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 1rem;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border-radius: 3px;
        }

        .progress-bar {
            height: 100%;
            background: var(--neon-green);
            width: 0%;
            box-shadow: 0 0 10px var(--neon-green);
            transition: width 0.1s linear;
        }

        /* --- HIDDEN YOUTUBE (Covered Visible Player Pattern) --- */
        /* Player must remain on-screen to avoid browser throttling. */
        /* Pushed behind the gallery layer (z-index -2). */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            overflow: hidden;
            z-index: -2;
            pointer-events: none;
        }

        /* --- START OVERLAY --- */
        #start-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .start-btn {
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 20px 60px;
            font-family: 'Courier Prime', monospace;
            font-size: 1.2rem;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            display: none;
            /* Hidden until ready */
        }

        .start-btn:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
        }

        /* --- TRACK DATE --- */
        #track-date {
            min-height: 1.2em;
        }
    </style>
</head>

<body>

    <!-- NARRATIVE GALLERY (Layer 0) -->
    <div id="bg-gallery">
        <img id="gallery-img-a" class="gallery-img active" />
        <img id="gallery-img-b" class="gallery-img" />
    </div>

    <!-- VISUALS -->
    <canvas id="fluid-canvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1 class="text-4xl md:text-6xl font-bold text-white mb-8 tracking-tighter">PIXELSTORTION</h1>
        <button id="init-btn" class="start-btn" onclick="startSystem()">INITIALIZE SYSTEM</button>
        <p id="loading-text" class="mt-4 text-gray-500 font-mono-custom text-xs animate-pulse">ESTABLISHING UPLINK...
        </p>
    </div>

    <!-- UI OVERLAY -->
    <div id="ui-layer">

        <!-- TOP BAR -->
        <div class="flex justify-between items-start">
            <div>
                <div class="text-[10px] text-green-500 font-mono-custom tracking-[0.2em] mb-1">CURRENT TRACK</div>
                <h1 id="track-title"
                    class="text-4xl md:text-7xl font-bold text-white leading-none tracking-tighter mix-blend-difference mb-2">
                    SILENCE</h1>
                <h2 id="track-artist" class="text-xl md:text-2xl text-gray-400 font-light">WAITING FOR INPUT...</h2>
                <h3 id="track-date" class="text-sm text-green-700 font-mono-custom tracking-widest mt-1"></h3>
            </div>

            <div class="text-right hidden md:block">
                <div class="text-[10px] text-gray-500 font-mono-custom tracking-[0.2em]">SYSTEM STATUS</div>
                <div id="status-indicator" class="text-green-500 font-bold">STANDBY</div>
            </div>
        </div>

        <!-- CENTER (Empty for visuals) -->

        <!-- BOTTOM CONTROLS -->
        <div class="w-full max-w-4xl mx-auto interactive">

            <!-- Controls -->
            <div class="flex items-center justify-center gap-6 mb-4">
                <button class="control-btn" onclick="jukebox.prev()">
                    <span class="material-symbols-outlined">skip_previous</span>
                </button>

                <button class="control-btn" style="width: 80px; height: 80px; border-color: white;"
                    onclick="jukebox.togglePlay()">
                    <span id="play-icon" class="material-symbols-outlined" style="font-size: 40px;">play_arrow</span>
                </button>

                <button class="control-btn" onclick="jukebox.next()">
                    <span class="material-symbols-outlined">skip_next</span>
                </button>

                <button class="control-btn" onclick="toggleFullscreen()">
                    <span class="material-symbols-outlined">fullscreen</span>
                </button>
            </div>

            <!-- Progress -->
            <div class="flex justify-between text-xs font-mono-custom text-gray-500 px-1">
                <span id="curr-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
            <div class="progress-container" onclick="jukebox.seek(event)">
                <div id="progress-bar" class="progress-bar"></div>
            </div>

            <div class="text-center mt-4">
                <p class="text-[10px] text-gray-600 font-mono-custom uppercase tracking-widest">
                    Catalogue: 45 Tracks // Mode: Random Access
                </p>
            </div>
        </div>
    </div>

    <!-- HIDDEN PLAYER -->
    <div id="video-container">
        <div id="player"></div>
    </div>

    <!-- FLUID ENGINE SCRIPT (External Library) -->
    <script src="js/fluid-simulator.js"></script>

    <!-- JUKEBOX LOGIC -->
    <script>
        // --- DATA ARCHIVE ---
        // galleryTrack maps to keys in gallery_map.json. storyDate from narrative metadata.
        const SONG_ARCHIVE = [
            { id: 1, title: "My Story", artist: "Ethel", videoId: "dLUClmr_Pf4", storyDate: "2024 (ARCHIVE REVIEW)", galleryTrack: "track_42" },
            { id: 2, title: "The Drop Pt.1", artist: "Ethel", videoId: "zHWwhom80go", storyDate: "NOV 14, 2016 (AGE 15)", galleryTrack: "track_02" },
            { id: 3, title: "The Drop Pt.2", artist: "Ethel", videoId: "K0ILO8MwX4Y", storyDate: "NOV 14, 2016 (AGE 15)", galleryTrack: "track_04" },
            { id: 4, title: "Structural Psychopathy", artist: "Dominic", videoId: "8rvIVBLZg2o", storyDate: "MAR 2019 (PROFILE)", galleryTrack: "track_08" },
            { id: 5, title: "Polished Vomit", artist: "Isla", videoId: "2hSYNLs7w3w", storyDate: null, galleryTrack: null },
            { id: 6, title: "Ride", artist: "Ethel", videoId: "0sgcZRtPO6s", storyDate: "JAN 20, 2019 (AGE 17)", galleryTrack: "track_10" },
            { id: 7, title: "Grief", artist: "Ethel", videoId: "PMy76HBgpL8", storyDate: "FEB 28, 2019 (THE CRASH)", galleryTrack: "track_12" },
            { id: 8, title: "Gotta Move", artist: "Ethel", videoId: "06qE_-OeIT0", storyDate: "MAR 02, 2019 (LEAVING HOME)", galleryTrack: "track_14" },
            { id: 9, title: "Won't Break Where Others End", artist: "Ethel", videoId: "fJNMlT7UeW0", storyDate: "MAR 05, 2019 (MOSMAN)", galleryTrack: "track_16" },
            { id: 10, title: "Peek-A-Boo", artist: "Isla", videoId: "K9lQ0IYiMoM", storyDate: null, galleryTrack: null },
            { id: 11, title: "I Built A Box", artist: "Ethel", videoId: "0F_prk5dGC4", storyDate: "JUN 2019 (THE SAFE HOUSE)", galleryTrack: "track_26" },
            { id: 12, title: "Same Breath", artist: "Dominic", videoId: "Ugy7KVuhwpE", storyDate: null, galleryTrack: null },
            { id: 13, title: "Burning Dominic's Bridge", artist: "Isla", videoId: "lwd7KOScg0k", storyDate: null, galleryTrack: null },
            { id: 14, title: "For You", artist: "Ethel", videoId: "f8o7zb3F-Xk", storyDate: "SEP 2019", galleryTrack: "track_30" },
            { id: 15, title: "Broken Edge", artist: "Isla", videoId: "_gvv_W5_x10", storyDate: "OCT 2019", galleryTrack: "track_32" },
            { id: 16, title: "Hero / Killer", artist: "Ethel", videoId: "YkQOXPzYkkU", storyDate: "FEB 2020 (THE TRIAL START)", galleryTrack: "track_34" },
            { id: 17, title: "Hero Complex", artist: "Dominic", videoId: "7gc3DigBW1Y", storyDate: null, galleryTrack: null },
            { id: 18, title: "I Don't Know", artist: "Ethel", videoId: "eXlF_5zHj3o", storyDate: null, galleryTrack: null },
            { id: 19, title: "I'm Not A Hero", artist: "Ethel", videoId: "9gA-F-2jR8", storyDate: null, galleryTrack: null },
            { id: 20, title: "It's Not My Fault", artist: "Dominic", videoId: "V_J_9-8-1-E", storyDate: null, galleryTrack: null },
            { id: 21, title: "Just A Job", artist: "Kinley", videoId: "x-8-7-6-5-4", storyDate: null, galleryTrack: null },
            { id: 22, title: "Kill Or Be Killed", artist: "Dominic", videoId: "1-2-3-4-5-6", storyDate: null, galleryTrack: null },
            { id: 23, title: "Left Behind", artist: "Isla", videoId: "a-b-c-d-e-f", storyDate: null, galleryTrack: null },
            { id: 24, title: "Look At Me Now", artist: "Isla", videoId: "g-h-i-j-k-l", storyDate: null, galleryTrack: null },
            { id: 25, title: "Lost In The Static", artist: "Sticky", videoId: "m-n-o-p-q-r", storyDate: null, galleryTrack: null },
            { id: 26, title: "Prison Escape", artist: "Dominic", videoId: "6eZwBGXGSO4", storyDate: "JAN 2024 (THE ESCAPE)", galleryTrack: "track_41" },
            { id: 27, title: "Guilt Money", artist: "Kinley", videoId: "uovMKnwE34M", storyDate: null, galleryTrack: null },
            { id: 28, title: "Ants on the Vine", artist: "Ethel", videoId: "e2wt2VSi9xA", storyDate: null, galleryTrack: null },
            { id: 29, title: "Clipboard Man", artist: "Ethel", videoId: "ZAhqNWTHTGU", storyDate: null, galleryTrack: "track_49" },
            { id: 30, title: "Rattled", artist: "Ethel", videoId: "qQ1l6JAjE8M", storyDate: null, galleryTrack: null },
            { id: 31, title: "Red Stick", artist: "Ethel", videoId: "iTOKsLS3jhM", storyDate: null, galleryTrack: "track_51" },
            { id: 32, title: "Can You Make A Mistake On Purpose?", artist: "Ethel", videoId: "s9Z8dgRk-Q8", storyDate: null, galleryTrack: "track_50" },
            { id: 33, title: "Intro to Normal?!", artist: "Ethel", videoId: "V0hvxqMWcnE", storyDate: null, galleryTrack: "track_53" },
            { id: 34, title: "Normal?!", artist: "Ethel", videoId: "OxHZnnRhtbk", storyDate: null, galleryTrack: null },
            { id: 35, title: "Normal?! (Special Version)", artist: "Ethel", videoId: "ht9PIloHD0Q", storyDate: null, galleryTrack: null },
            { id: 36, title: "Memory Under Water", artist: "Isla", videoId: "nk4Re7OjTTM", storyDate: null, galleryTrack: "track_58" },
            { id: 37, title: "The Porcelain Lie", artist: "Isla", videoId: "fNVKsxe_EcM", storyDate: null, galleryTrack: "track_60" },
            { id: 38, title: "Raise The Fourth", artist: "Isla", videoId: "ey20cJsY82M", storyDate: null, galleryTrack: "track_59" },
            { id: 39, title: "What You Don't See", artist: "Isla", videoId: "Y4VC6mh37NI", storyDate: null, galleryTrack: "track_65" },
            { id: 40, title: "What You Don't See (Symphony)", artist: "Isla", videoId: "hm2kp7LOhsg", storyDate: null, galleryTrack: "track_68" },
            { id: 41, title: "Raise The Fourth (With Symphony)", artist: "Isla", videoId: "ZBLMDbwcy4g", storyDate: null, galleryTrack: null },
            { id: 42, title: "Give It Back", artist: "Isla", videoId: "Aw2ZAkxp6b0", storyDate: null, galleryTrack: "track_69" },
            { id: 43, title: "Don't Wake Him Yet", artist: "Isla", videoId: "NwqHLFYR1mA", storyDate: null, galleryTrack: "track_64" },
            { id: 44, title: "Melody of Normality", artist: "Isla", videoId: "a4TpIhna55k", storyDate: null, galleryTrack: "track_66" },
            { id: 45, title: "What This Was Always For", artist: "Isla", videoId: "X9EUb1_QC9c", storyDate: null, galleryTrack: "track_70" }
        ];

        // --- GALLERY ENGINE (Image Slideshow) ---
        // Loads narrative images from gallery_map.json and crossfades them behind the fluid
        class GalleryEngine {
            constructor() {
                this.galleryMap = null;
                this.currentImages = [];
                this.currentIndex = 0;
                this.activeSlot = 'a';
                this.intervalId = null;
                this.imgA = document.getElementById('gallery-img-a');
                this.imgB = document.getElementById('gallery-img-b');
                this.container = document.getElementById('bg-gallery');
                this.onImageReady = null; // Callback for ColorExtractor
            }

            async loadMap() {
                try {
                    const resp = await fetch('library/char_ethel_media/gallery_map.json');
                    this.galleryMap = await resp.json();
                    console.log('[Gallery] Map loaded:', Object.keys(this.galleryMap).length, 'tracks');
                } catch (e) {
                    console.warn('[Gallery] Failed to load gallery_map.json:', e);
                }
            }

            loadTrack(galleryTrack) {
                // Aggressively clear any running interval before anything else
                this.stopCycling();
                this.currentIndex = 0;

                if (!galleryTrack || !this.galleryMap || !this.galleryMap[galleryTrack]) {
                    // No gallery for this track — hide the container entirely
                    this.currentImages = [];
                    this.container.style.opacity = '0';
                    // Remove active class from both slots so previous images don't linger
                    this.imgA.classList.remove('active');
                    this.imgB.classList.remove('active');
                    return;
                }

                this.currentImages = this.galleryMap[galleryTrack];
                this.container.style.opacity = '1';

                // Show the first image immediately
                if (this.currentImages.length > 0) {
                    this.showImage(this.currentImages[0]);
                }
            }

            showImage(url) {
                const target = this.activeSlot === 'a' ? this.imgA : this.imgB;
                const other = this.activeSlot === 'a' ? this.imgB : this.imgA;

                // CRITICAL: Set crossOrigin BEFORE src to avoid tainted canvas
                target.crossOrigin = 'Anonymous';
                target.onload = () => {
                    target.classList.add('active');
                    other.classList.remove('active');
                    this.activeSlot = this.activeSlot === 'a' ? 'b' : 'a';

                    // Notify the color extractor that a new image is ready
                    if (this.onImageReady) this.onImageReady(target);
                };
                target.onerror = () => {
                    console.warn('[Gallery] Failed to load image:', url);
                };
                target.src = url;
            }

            startCycling() {
                this.stopCycling();
                if (this.currentImages.length <= 1) return;

                this.intervalId = setInterval(() => {
                    this.currentIndex = (this.currentIndex + 1) % this.currentImages.length;
                    this.showImage(this.currentImages[this.currentIndex]);
                }, 6000);
            }

            stopCycling() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
            }
        }

        // --- COLOR EXTRACTOR (The Brains) ---
        // Draws current gallery image to a tiny off-screen canvas, samples vibrant colors
        class ColorExtractor {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.canvas.width = 64;  // Tiny — we only need color samples
                this.canvas.height = 64;
                this.currentPalette = [];
            }

            extractFromImage(img) {
                try {
                    this.ctx.drawImage(img, 0, 0, 64, 64);
                    const data = this.ctx.getImageData(0, 0, 64, 64).data;
                    const palette = [];
                    let attempts = 0;

                    // Sample up to 8 vibrant colors, filtering out mud
                    while (palette.length < 8 && attempts < 50) {
                        const x = Math.floor(Math.random() * 64);
                        const y = Math.floor(Math.random() * 64);
                        const idx = (y * 64 + x) * 4;
                        const r = data[idx] / 255;
                        const g = data[idx + 1] / 255;
                        const b = data[idx + 2] / 255;

                        // Luminance filter: reject pure shadows and pure highlights
                        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                        // Saturation filter: reject desaturated greys
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        const saturation = max === 0 ? 0 : (max - min) / max;

                        if (luminance > 0.1 && luminance < 0.9 && saturation > 0.12) {
                            palette.push({ r, g, b });
                        }
                        attempts++;
                    }

                    if (palette.length > 0) {
                        this.currentPalette = palette;
                        console.log('[Color] Extracted', palette.length, 'vibrant colors');
                    } else {
                        console.log('[Color] No vibrant colors found, keeping previous palette');
                    }
                } catch (e) {
                    // CORS tainted canvas — fail silently, keep existing palette or fallback
                    console.warn('[Color] Extraction failed (CORS?):', e.message);
                }
            }

            getRandomColor() {
                if (this.currentPalette.length > 0) {
                    return this.currentPalette[Math.floor(Math.random() * this.currentPalette.length)];
                }
                // Fallback: green/matrix color scheme
                return { r: 0, g: Math.random() * 0.8 + 0.2, b: Math.random() * 0.25 };
            }
        }

        // --- BEAT ENGINE (Visual Logic) ---
        // Generates explosive visuals based on emulated BPM since we can't get real audio data from YouTube IFrame
        class BeatEngine {
            constructor(fluidEngine) {
                this.fluid = fluidEngine;
                this.active = false;
                this.interval = null;
                this.bpm = 120;
                this.lastBeat = 0;
            }

            start() {
                this.active = true;
                this.loop();
            }

            stop() {
                this.active = false;
                if (this.interval) clearTimeout(this.interval);
            }

            loop() {
                if (!this.active) return;

                // Randomize BPM slightly to feel organic for different songs
                const variance = Math.random() * 200;
                const msPerBeat = (60000 / this.bpm) - variance;

                this.interval = setTimeout(() => {
                    this.triggerBeat();
                    this.loop();
                }, msPerBeat);
            }

            triggerBeat() {
                // Determine intensity (Random chance for a "Drop")
                const intensity = Math.random();

                if (intensity > 0.8) {
                    // BIG EXPLOSION — multiple splats via splatStack
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        this.fluid.splatStack.push({
                            x: 0.5 + Math.cos(angle) * Math.random() * 0.15,
                            y: 0.5 + Math.sin(angle) * Math.random() * 0.15,
                            dx: Math.cos(angle) * 3000,
                            dy: Math.sin(angle) * 3000,
                            color: colorExtractor.getRandomColor()
                        });
                    }
                    const tt = document.getElementById('track-title');
                    if (tt) {
                        tt.style.textShadow = '0 0 20px #00ff41';
                        setTimeout(() => tt.style.textShadow = 'none', 100);
                    }
                } else if (intensity > 0.4) {
                    // Small Splat — single push to splatStack (normalized 0-1 coords)
                    this.fluid.splatStack.push({
                        x: Math.random(),
                        y: Math.random(),
                        dx: (Math.random() - 0.5) * 1000,
                        dy: (Math.random() - 0.5) * 1000,
                        color: colorExtractor.getRandomColor()
                    });
                }
            }
        }

        // --- JUKEBOX CONTROLLER ---
        class Jukebox {
            constructor() {
                this.player = null;
                this.currentTrackIndex = -1;
                this.playedHistory = [];
                this.isPlaying = false;
                this.beatEngine = null;
            }

            init(fluidEngine) {
                this.beatEngine = new BeatEngine(fluidEngine);
            }

            loadRandomTrack() {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * SONG_ARCHIVE.length);
                } while (newIndex === this.currentTrackIndex && SONG_ARCHIVE.length > 1);

                this.loadTrack(newIndex);
            }

            loadTrack(index) {
                this.currentTrackIndex = index;
                const track = SONG_ARCHIVE[index];

                // UI Update
                document.getElementById('track-title').innerText = track.title;
                document.getElementById('track-artist').innerText = track.artist;
                document.getElementById('track-date').innerText = track.storyDate || '';
                document.getElementById('status-indicator').innerText = "BUFFERING";

                // Gallery Update — load images for this track
                if (galleryEngine) {
                    galleryEngine.loadTrack(track.galleryTrack);
                }

                // Load Video
                if (this.player && this.player.loadVideoById) {
                    this.player.loadVideoById(track.videoId);
                }
            }

            togglePlay() {
                if (!this.player) return;
                const state = this.player.getPlayerState();
                if (state === 1) { // Playing
                    this.player.pauseVideo();
                } else {
                    this.player.playVideo();
                }
            }

            next() {
                this.loadRandomTrack();
            }

            prev() {
                // For a random jukebox, prev just loads another random track (chaos mode)
                this.loadRandomTrack();
            }

            seek(event) {
                if (!this.player) return;
                const container = document.querySelector('.progress-container');
                const rect = container.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, clickX / rect.width));
                const duration = this.player.getDuration();
                this.player.seekTo(duration * percent, true);
            }

            onStateChange(event) {
                const status = document.getElementById('status-indicator');
                const playIcon = document.getElementById('play-icon');

                if (event.data === YT.PlayerState.PLAYING) {
                    this.isPlaying = true;
                    status.innerText = "PLAYING";
                    status.style.color = "#00ff41"; // Neon Green
                    playIcon.innerText = "pause";
                    this.beatEngine.start(); // Start Visuals
                    if (galleryEngine) galleryEngine.startCycling(); // Start Slideshow
                }
                else if (event.data === YT.PlayerState.PAUSED) {
                    this.isPlaying = false;
                    status.innerText = "PAUSED";
                    status.style.color = "orange";
                    playIcon.innerText = "play_arrow";
                    this.beatEngine.stop(); // Stop Visuals
                    if (galleryEngine) galleryEngine.stopCycling(); // Pause Slideshow
                }
                else if (event.data === YT.PlayerState.ENDED) {
                    this.isPlaying = false;
                    status.innerText = "LOADING NEXT...";
                    this.beatEngine.stop();
                    if (galleryEngine) galleryEngine.stopCycling();
                    this.next(); // Auto-advance
                }
            }

            updateProgress() {
                if (!this.player || !this.isPlaying) return;

                const curr = this.player.getCurrentTime();
                const total = this.player.getDuration();

                if (total > 0) {
                    const pct = (curr / total) * 100;
                    document.getElementById('progress-bar').style.width = `${pct}%`;
                    document.getElementById('curr-time').innerText = this.formatTime(curr);
                    document.getElementById('total-time').innerText = this.formatTime(total);
                }
            }

            formatTime(s) {
                const m = Math.floor(s / 60);
                const secs = Math.floor(s % 60);
                return `${m}:${secs < 10 ? '0' : ''}${secs}`;
            }

            onError(event) {
                console.warn("YouTube Player Error:", event.data);
                const status = document.getElementById('status-indicator');
                if (status) {
                    status.innerText = "SIGNAL LOST";
                    status.style.color = "red";
                }

                // Fallback: Start visual engine in "Simulation Mode"
                if (this.beatEngine && !this.beatEngine.active) {
                    console.log("Activating Visual Fallback Mode");
                    this.beatEngine.start();
                }
            }
        }

        // --- INITIALIZATION ---
        let fluid;
        let galleryEngine;
        let colorExtractor;
        const jukebox = new Jukebox();

        function startSystem() {
            console.log('[JB] startSystem() called');

            // Remove Overlay
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => overlay.remove(), 500);

            // ── DIAGNOSTIC: Check canvas element ──
            const canvasEl = document.getElementById('fluid-canvas');
            console.log('[JB] Canvas element:', canvasEl);
            console.log('[JB] Canvas clientWidth:', canvasEl?.clientWidth, 'clientHeight:', canvasEl?.clientHeight);

            if (!canvasEl) {
                console.error('[JB] FATAL: Canvas element #fluid-canvas not found!');
                return;
            }

            // ── DIAGNOSTIC: Check if FluidSimulator class exists ──
            console.log('[JB] FluidSimulator class:', typeof FluidSimulator);
            if (typeof FluidSimulator === 'undefined') {
                console.error('[JB] FATAL: FluidSimulator class not loaded! Check js/fluid-simulator.js');
                // FALLBACK: Draw green screen to prove canvas is visible
                const ctx = canvasEl.getContext('2d');
                if (ctx) {
                    canvasEl.width = window.innerWidth;
                    canvasEl.height = window.innerHeight;
                    ctx.fillStyle = '#00ff41';
                    ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                    ctx.fillStyle = '#000';
                    ctx.font = '48px monospace';
                    ctx.fillText('FLUID ENGINE FAILED TO LOAD', 50, 100);
                }
                return;
            }

            // ── Init Fluid (External Library) ──
            try {
                fluid = new FluidSimulator(canvasEl, null);
                console.log('[JB] FluidSimulator created:', fluid);
                console.log('[JB] fluid.gl:', fluid?.gl);
                console.log('[JB] fluid.ext:', fluid?.ext);
                console.log('[JB] fluid.splatStack:', fluid?.splatStack);
                console.log('[JB] fluid.canvas.width:', fluid?.canvas?.width, 'height:', fluid?.canvas?.height);
            } catch (e) {
                console.error('[JB] FluidSimulator constructor THREW:', e);
                return;
            }

            if (!fluid || !fluid.gl) {
                console.error('[JB] FATAL: FluidSimulator created but gl context is null!');
                return;
            }

            // ── Init Gallery & Color Extraction Engine ──
            galleryEngine = new GalleryEngine();
            colorExtractor = new ColorExtractor();
            galleryEngine.onImageReady = (img) => colorExtractor.extractFromImage(img);
            galleryEngine.loadMap(); // Async — loads gallery_map.json in background

            // Init Jukebox Logic
            jukebox.init(fluid);

            // FORCE START VISUALS NOW
            console.log("[JB] Pushing initial splats...");
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                fluid.splatStack.push({
                    x: 0.5 + Math.cos(angle) * 0.1,
                    y: 0.5 + Math.sin(angle) * 0.1,
                    dx: Math.cos(angle) * 4000,
                    dy: Math.sin(angle) * 4000,
                    color: { r: 0.0, g: 1.0, b: 0.25 }
                });
            }
            console.log("[JB] splatStack after push:", fluid.splatStack.length, "items");
            jukebox.beatEngine.start();
            console.log("[JB] BeatEngine started");

            // Start Progress Loop
            setInterval(() => jukebox.updateProgress(), 1000);

            // Play the first track immediately
            if (jukebox.player) {
                jukebox.loadRandomTrack();
            } else {
                console.warn("[JB] Player not ready yet, retrying...");
                setTimeout(() => jukebox.loadRandomTrack(), 1000);
            }
            console.log("[JB] startSystem() complete");
        }

        // Load YouTube API Immediately on Page Load
        function onYouTubeIframeAPIReady() {
            jukebox.player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'playsinline': 1,
                    'controls': 0,
                    'disablekb': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': (e) => jukebox.onStateChange(e),
                    'onError': (e) => jukebox.onError(e)
                }
            });
        }

        function onPlayerReady(event) {
            console.log("Player Ready - Waiting for User Command");
            // Change text to show ready
            const loadingText = document.getElementById('loading-text');
            const initBtn = document.getElementById('init-btn');

            if (loadingText && initBtn) {
                loadingText.style.display = 'none'; // Hide loading text
                initBtn.style.display = 'block'; // Show button
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

    </script>
</body>

</html>