<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crimson Rebel | 3D Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .progress-bar {
            width: 200px;
            height: 2px;
            background: #333;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: #ff003c;
            width: 0%;
            transition: width 0.1s;
        }

        /* Glitch Text Effect */
        .glitch {
            position: relative;
            color: #fff;
            font-size: 4rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 2px 2px #ff003c, -2px -2px #00e5ff;
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }

        .glitch::before {
            content: attr(data-text);
            position: absolute;
            left: 2px;
            text-shadow: -1px 0 #ff003c;
            top: 0;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }

        .glitch::after {
            content: attr(data-text);
            position: absolute;
            left: -2px;
            text-shadow: -1px 0 #00e5ff;
            top: 0;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% {
                clip: rect(31px, 9999px, 91px, 0);
                transform: skew(0.85deg);
            }

            20% {
                clip: rect(7px, 9999px, 86px, 0);
                transform: skew(0.2deg);
            }

            40% {
                clip: rect(63px, 9999px, 11px, 0);
                transform: skew(0.04deg);
            }

            60% {
                clip: rect(2px, 9999px, 58px, 0);
                transform: skew(0.67deg);
            }

            80% {
                clip: rect(89px, 9999px, 2px, 0);
                transform: skew(0.34deg);
            }

            100% {
                clip: rect(48px, 9999px, 66px, 0);
                transform: skew(0.12deg);
            }
        }

        @keyframes glitch-anim2 {
            0% {
                clip: rect(65px, 9999px, 100px, 0);
                transform: skew(0.4deg);
            }

            20% {
                clip: rect(3px, 9999px, 3px, 0);
                transform: skew(0.9deg);
            }

            40% {
                clip: rect(12px, 9999px, 83px, 0);
                transform: skew(0.05deg);
            }

            60% {
                clip: rect(81px, 9999px, 42px, 0);
                transform: skew(0.5deg);
            }

            80% {
                clip: rect(10px, 9999px, 2px, 0);
                transform: skew(0.2deg);
            }

            100% {
                clip: rect(34px, 9999px, 12px, 0);
                transform: skew(0.7deg);
            }
        }

        .overlay-text {
            font-family: 'Arial', sans-serif;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 2px;
        }
    </style>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="glitch" data-text="LOADING SYSTEM" style="font-size: 2rem;">LOADING SYSTEM</div>
        <div class="progress-bar">
            <div id="progress" class="progress-fill"></div>
        </div>
        <div id="loading-text" class="mt-2 text-xs text-gray-500">INITIALIZING ASSETS...</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-8">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="glitch" data-text="CRIMSON REBEL" style="font-size: 3rem; margin: 0;">CRIMSON REBEL</h1>
                <p class="text-red-500 tracking-widest text-xs mt-2">PROJECT: ETHEL_MESH_V1</p>
            </div>
            <div class="text-right">
                <p class="overlay-text">COORD: 34.0522° N, 118.2437° W</p>
                <p class="overlay-text">STATUS: CONNECTED</p>
            </div>
        </div>

        <div class="flex justify-between items-end">
            <div class="w-64">
                <p class="text-xs text-gray-400 mb-2">RENDER METRICS</p>
                <div class="h-px w-full bg-gray-800 mb-1"></div>
                <div class="flex justify-between text-xs text-red-500">
                    <span>BLOOM</span>
                    <span>ACTIVE</span>
                </div>
                <div class="flex justify-between text-xs text-gray-500">
                    <span>HDR ENV</span>
                    <span>LOADED</span>
                </div>
            </div>
            <div class="text-right">
                <div class="border border-red-900 p-4 bg-black/50 backdrop-blur-sm">
                    <p class="text-xs text-white">INTERACTION MODE</p>
                    <p class="text-[10px] text-gray-400 mt-1">LMB: ROTATE | RMB: PAN | SCROLL: ZOOM</p>
                </div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Main 3D Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

        // Configuration
        const ASSETS = {
            basePath: 'https://raw.githubusercontent.com/NJsalubrious/pixelstortion-assets/02fbae690794b6b51eb5b8115fde695960be1cbd/library/3dMeshes/EthelTest/',
            model: 'Meshy_AI_Crimson_Rebel_0214122239_texture.fbx',
            map: 'Meshy_AI_Crimson_Rebel_0214122239_texture.png',
            metal: 'Meshy_AI_Crimson_Rebel_0214122239_texture_metallic.png',
            rough: 'Meshy_AI_Crimson_Rebel_0214122239_texture_roughness.png',
            normal: 'Meshy_AI_Crimson_Rebel_0214122239_texture_normal.png',
            envMap: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/shanghai_bund_1k.hdr' // Moody urban lighting
        };

        // State
        let camera, scene, renderer, composer, controls, mixer;
        let model;
        const clock = new THREE.Clock();
        const loadingManager = new THREE.LoadingManager();

        // UI Elements
        const loaderEl = document.getElementById('loader');
        const progressEl = document.getElementById('progress');
        const loadingText = document.getElementById('loading-text');

        init();
        animate();

        function init() {
            // Container
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02); // Distance fog for depth

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.5, 3.5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 10;
            controls.target.set(0, 1, 0);

            // Loading Manager Setup
            loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const percent = (itemsLoaded / itemsTotal) * 100;
                progressEl.style.width = percent + '%';
                loadingText.innerText = `LOADING RESOURCE: ${itemsLoaded} / ${itemsTotal}`;
            };

            loadingManager.onLoad = () => {
                // Fade out loader
                loaderEl.style.transition = 'opacity 0.5s';
                loaderEl.style.opacity = '0';
                setTimeout(() => { loaderEl.style.display = 'none'; }, 500);
                console.log('All assets loaded');
            };

            // --- LIGHTING ---

            // 1. Ambient - very low, let the lights do the work
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Soft white light
            scene.add(ambientLight);

            // 2. Main Key Light (Cool Blue/White)
            const keyLight = new THREE.DirectionalLight(0xffffff, 2);
            keyLight.position.set(5, 5, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            scene.add(keyLight);

            // 3. Rim Light (Intense Red for "Crimson" aesthetic)
            const rimLight = new THREE.SpotLight(0xff003c, 10);
            rimLight.position.set(-2, 2, -2);
            rimLight.lookAt(0, 1, 0);
            rimLight.distance = 10;
            scene.add(rimLight);

            // 4. Fill Light (Subtle Teal for contrast)
            const fillLight = new THREE.PointLight(0x00e5ff, 1);
            fillLight.position.set(2, 0.5, 2);
            scene.add(fillLight);

            // --- ASSETS ---

            // Environment Map
            new RGBELoader(loadingManager).load(ASSETS.envMap, (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                // scene.background = texture; // Uncomment to see the city, keeping black for style
                scene.environmentIntensity = 0.8;
            });

            // Textures
            const textureLoader = new THREE.TextureLoader(loadingManager);
            const tMap = textureLoader.load(ASSETS.basePath + ASSETS.map);
            const tMetal = textureLoader.load(ASSETS.basePath + ASSETS.metal);
            const tRough = textureLoader.load(ASSETS.basePath + ASSETS.rough);
            const tNormal = textureLoader.load(ASSETS.basePath + ASSETS.normal);

            // Fix texture colorspace
            tMap.colorSpace = THREE.SRGBColorSpace;

            // FBX Model
            const loader = new FBXLoader(loadingManager);
            loader.load(ASSETS.basePath + ASSETS.model, (object) => {

                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Apply PBR Material
                        child.material = new THREE.MeshStandardMaterial({
                            map: tMap,
                            normalMap: tNormal,
                            metalnessMap: tMetal,
                            roughnessMap: tRough,
                            metalness: 1.0, // Multiplier for the map
                            roughness: 1.0, // Multiplier for the map
                            envMapIntensity: 1.0
                        });

                        // Fix for some FBX imports having weird normals
                        child.geometry.computeVertexNormals();
                    }
                });

                // Scale and position
                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3());
                const scaleFactor = 1.8 / size.y; // Normalize height to approx 1.8 units
                object.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // Recompute bounding box after scaling
                const scaledBox = new THREE.Box3().setFromObject(object);
                const scaledSize = scaledBox.getSize(new THREE.Vector3());
                const scaledCenter = scaledBox.getCenter(new THREE.Vector3());

                // Center horizontally, lift by half height
                object.position.x += (object.position.x - scaledCenter.x);
                object.position.y += (object.position.y - scaledCenter.y) + scaledSize.y / 2;
                object.position.z += (object.position.z - scaledCenter.z);

                // Create a reflection plane (wet street look)
                createReflectionPlane();

                model = object;
                scene.add(object);

                // Add Animation Mixer if model has animations (FBX often do)
                if (object.animations && object.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(object);
                    const action = mixer.clipAction(object.animations[0]);
                    action.play();
                }

            }, undefined, (error) => {
                console.error(error);
                loadingText.innerText = "ERROR LOADING MODEL. CHECK CONSOLE.";
                loadingText.style.color = "red";
            });

            // --- POST PROCESSING ---
            const renderScene = new RenderPass(scene, camera);

            // Bloom
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // Don't bloom dark things
            bloomPass.strength = 0.4; // Glow intensity
            bloomPass.radius = 0.5;

            // Film Grain (for that gritty aesthetic)
            const filmPass = new FilmPass(
                0.35,   // noise intensity
                0.025,  // scanline intensity
                648,    // scanline count
                false   // grayscale
            );

            const outputPass = new OutputPass();

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(filmPass);
            composer.addPass(outputPass);

            // Events
            window.addEventListener('resize', onWindowResize);
        }

        function createReflectionPlane() {
            // A simple dark plane to catch shadows and reflections
            const geometry = new THREE.PlaneGeometry(20, 20);
            const material = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.7,
                metalness: 0.15
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Grid helper for tech vibe
            const grid = new THREE.GridHelper(20, 40, 0xff003c, 0x222222);
            grid.position.y = 0.01;
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);
            controls.update();

            // Subtle camera movement for "cinematic" feel if user isn't interacting heavily
            // (Optional, can be disabled if distracting)
            // const time = Date.now() * 0.0005;
            // camera.position.y += Math.sin(time) * 0.001;

            composer.render();
        }
    </script>
</body>

</html>