<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PIXELSTORTION // JUKEBOX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0"
        rel="stylesheet" />

    <style>
        :root {
            --neon-green: #00ff41;
            --fire-orange: #ff4500;
            --void: #050505;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void);
            overflow: hidden;
            font-family: 'Space Grotesk', sans-serif;
            cursor: crosshair;
        }

        /* --- VISUAL LAYERS --- */
        #fluid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle, transparent 50%, black 120%);
            z-index: 5;
            pointer-events: none;
        }

        /* --- UI LAYERS --- */
        #ui-layer {
            position: fixed;
            inset: 0;
            z-index: 20;
            pointer-events: none;
            /* Let clicks pass to fluid */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .interactive {
            pointer-events: auto;
        }

        /* --- TYPOGRAPHY --- */
        .glitch-text {
            font-family: 'Space Grotesk', sans-serif;
            text-transform: uppercase;
            position: relative;
            color: white;
            mix-blend-mode: difference;
        }

        .font-mono-custom {
            font-family: 'Courier Prime', monospace;
        }

        /* --- CONTROLS --- */
        .control-btn {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .control-btn:hover {
            border-color: var(--neon-green);
            color: var(--neon-green);
            transform: scale(1.1);
            background: rgba(0, 20, 0, 0.6);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* --- PROGRESS BAR --- */
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 1rem;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border-radius: 3px;
        }

        .progress-bar {
            height: 100%;
            background: var(--neon-green);
            width: 0%;
            box-shadow: 0 0 10px var(--neon-green);
            transition: width 0.1s linear;
        }

        /* --- HIDDEN YOUTUBE (Covered Visible Player Pattern) --- */
        /* Player must remain on-screen to avoid browser throttling. */
        /* It sits behind the fluid canvas (z-index 0 vs canvas z-index 1). */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }

        /* --- START OVERLAY --- */
        #start-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .start-btn {
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 20px 60px;
            font-family: 'Courier Prime', monospace;
            font-size: 1.2rem;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            display: none;
            /* Hidden until ready */
        }

        .start-btn:hover {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
        }
    </style>
</head>

<body>

    <!-- VISUALS -->
    <canvas id="fluid-canvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1 class="text-4xl md:text-6xl font-bold text-white mb-8 tracking-tighter">PIXELSTORTION</h1>
        <button id="init-btn" class="start-btn" onclick="startSystem()">INITIALIZE SYSTEM</button>
        <p id="loading-text" class="mt-4 text-gray-500 font-mono-custom text-xs animate-pulse">ESTABLISHING UPLINK...
        </p>
    </div>

    <!-- UI OVERLAY -->
    <div id="ui-layer">

        <!-- TOP BAR -->
        <div class="flex justify-between items-start">
            <div>
                <div class="text-[10px] text-green-500 font-mono-custom tracking-[0.2em] mb-1">CURRENT TRACK</div>
                <h1 id="track-title"
                    class="text-4xl md:text-7xl font-bold text-white leading-none tracking-tighter mix-blend-difference mb-2">
                    SILENCE</h1>
                <h2 id="track-artist" class="text-xl md:text-2xl text-gray-400 font-light">WAITING FOR INPUT...</h2>
            </div>

            <div class="text-right hidden md:block">
                <div class="text-[10px] text-gray-500 font-mono-custom tracking-[0.2em]">SYSTEM STATUS</div>
                <div id="status-indicator" class="text-green-500 font-bold">STANDBY</div>
            </div>
        </div>

        <!-- CENTER (Empty for visuals) -->

        <!-- BOTTOM CONTROLS -->
        <div class="w-full max-w-4xl mx-auto interactive">

            <!-- Controls -->
            <div class="flex items-center justify-center gap-6 mb-4">
                <button class="control-btn" onclick="jukebox.prev()">
                    <span class="material-symbols-outlined">skip_previous</span>
                </button>

                <button class="control-btn" style="width: 80px; height: 80px; border-color: white;"
                    onclick="jukebox.togglePlay()">
                    <span id="play-icon" class="material-symbols-outlined" style="font-size: 40px;">play_arrow</span>
                </button>

                <button class="control-btn" onclick="jukebox.next()">
                    <span class="material-symbols-outlined">skip_next</span>
                </button>

                <button class="control-btn" onclick="toggleFullscreen()">
                    <span class="material-symbols-outlined">fullscreen</span>
                </button>
            </div>

            <!-- Progress -->
            <div class="flex justify-between text-xs font-mono-custom text-gray-500 px-1">
                <span id="curr-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
            <div class="progress-container" onclick="jukebox.seek(event)">
                <div id="progress-bar" class="progress-bar"></div>
            </div>

            <div class="text-center mt-4">
                <p class="text-[10px] text-gray-600 font-mono-custom uppercase tracking-widest">
                    Catalogue: 44 Tracks // Mode: Random Access
                </p>
            </div>
        </div>
    </div>

    <!-- HIDDEN PLAYER -->
    <div id="video-container">
        <div id="player"></div>
    </div>

    <!-- FLUID ENGINE SCRIPT (Embedded for single-file portability and custom tuning) -->
    <script>
        /**
         * PIXELSTORTION FLUID ENGINE (Custom Jukebox Tuning)
         * Optimized for "Explosive" visual reactivity.
         */
        const CONFIG = {
            SIM_RESOLUTION: 256,
            DYE_RESOLUTION: 1024,
            DENSITY_DISSIPATION: 0.96, // Trails last longer
            VELOCITY_DISSIPATION: 0.98,
            PRESSURE: 0.8,
            PRESSURE_ITERATIONS: 20,
            CURL: 45, // High curl for chaotic smoke
            SPLAT_RADIUS: 0.35,
            SPLAT_FORCE: 6000,
            BLOOM: true,
            BLOOM_ITERATIONS: 8,
            BLOOM_RESOLUTION: 256,
            BLOOM_INTENSITY: 0.8,
            BLOOM_THRESHOLD: 0.5,
            BLOOM_SOFT_KNEE: 0.7,
            COLOR_UPDATE_SPEED: 10
        };

        // --- SHADER SOURCES ---
        const shaders = {
            vertex: `precision highp float; attribute vec2 aPosition; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform vec2 texelSize; void main () { vUv = aPosition * 0.5 + 0.5; vL = vUv - vec2(texelSize.x, 0.0); vR = vUv + vec2(texelSize.x, 0.0); vT = vUv + vec2(0.0, texelSize.y); vB = vUv - vec2(0.0, texelSize.y); gl_Position = vec4(aPosition, 0.0, 1.0); }`,
            splat: `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uTarget; uniform float aspectRatio; uniform vec3 color; uniform vec2 point; uniform float radius; void main () { vec2 p = vUv - point.xy; p.x *= aspectRatio; vec3 splat = exp(-dot(p, p) / radius) * color; vec3 base = texture2D(uTarget, vUv).xyz; gl_FragColor = vec4(base + splat, 1.0); }`,
            advection: `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uVelocity; uniform sampler2D uSource; uniform vec2 texelSize; uniform vec2 dyeTexelSize; uniform float dt; uniform float dissipation; void main () { vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize; vec4 result = dissipation * texture2D(uSource, coord); float decay = 1.0 + dissipation * dt; gl_FragColor = vec4(result.rgb / decay, 1.0); }`,
            divergence: `precision mediump float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uVelocity; void main () { float L = texture2D(uVelocity, vL).x; float R = texture2D(uVelocity, vR).x; float T = texture2D(uVelocity, vT).y; float B = texture2D(uVelocity, vB).y; vec2 C = texture2D(uVelocity, vUv).xy; if (vL.x < 0.0) { L = -C.x; } if (vR.x > 1.0) { R = -C.x; } if (vT.y > 1.0) { T = -C.y; } if (vB.y < 0.0) { B = -C.y; } float div = 0.5 * (R - L + T - B); gl_FragColor = vec4(div, 0.0, 0.0, 1.0); }`,
            curl: `precision mediump float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uVelocity; void main () { float L = texture2D(uVelocity, vL).y; float R = texture2D(uVelocity, vR).y; float T = texture2D(uVelocity, vT).x; float B = texture2D(uVelocity, vB).x; float vorticity = R - L - T + B; gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0); }`,
            vorticity: `precision highp float; precision highp sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uVelocity; uniform sampler2D uCurl; uniform float curl; uniform float dt; void main () { float L = texture2D(uCurl, vL).x; float R = texture2D(uCurl, vR).x; float T = texture2D(uCurl, vT).x; float B = texture2D(uCurl, vB).x; float C = texture2D(uCurl, vUv).x; vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L)); force /= length(force) + 0.0001; force *= curl * C; force.y *= -1.0; vec2 velocity = texture2D(uVelocity, vUv).xy; velocity += force * dt; gl_FragColor = vec4(velocity, 0.0, 1.0); }`,
            pressure: `precision mediump float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uPressure; uniform sampler2D uDivergence; void main () { float L = texture2D(uPressure, vL).x; float R = texture2D(uPressure, vR).x; float T = texture2D(uPressure, vT).x; float B = texture2D(uPressure, vB).x; float divergence = texture2D(uDivergence, vUv).x; float pressure = (L + R + B + T - divergence) * 0.25; gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0); }`,
            gradientSubtract: `precision mediump float; precision mediump sampler2D; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform sampler2D uPressure; uniform sampler2D uVelocity; void main () { float L = texture2D(uPressure, vL).x; float R = texture2D(uPressure, vR).x; float T = texture2D(uPressure, vT).x; float B = texture2D(uPressure, vB).x; vec2 velocity = texture2D(uVelocity, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0.0, 1.0); }`,
            display: `precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D uTexture; void main () { vec3 c = texture2D(uTexture, vUv).rgb; c = c / (c + vec3(1.0)); c = pow(c, vec3(1.0 / 2.2)); gl_FragColor = vec4(c, 1.0); }`
        };

        class FluidEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2', { alpha: true, depth: false, antialias: false });
                if (!this.gl) {
                    console.error("WebGL 2.0 not available");
                    return;
                }

                this.ext = this.gl.getExtension('EXT_color_buffer_float');
                this.gl.getExtension('OES_texture_float_linear');

                this.programs = {};
                this.fbo = {};

                this.init();
                this.lastTime = Date.now();
                this.loop();
            }

            init() {
                const gl = this.gl;
                this.compilePrograms();

                // Fullscreen quad
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);

                window.addEventListener('resize', () => this.resize());

                // CRITICAL: Resize must happen BEFORE FBO init to prevent 0x0 errors
                this.resize();

                // Mouse/Touch Interaction
                this.pointers = [];
                window.addEventListener('mousemove', e => this.updatePointer(e.clientX, e.clientY));
                window.addEventListener('touchmove', e => this.updatePointer(e.touches[0].clientX, e.touches[0].clientY));
                window.addEventListener('mousedown', e => { this.updatePointer(e.clientX, e.clientY); this.pointers[0].down = true; this.pointers[0].color = this.generateColor(); });
                window.addEventListener('mouseup', () => { if (this.pointers[0]) this.pointers[0].down = false; });
            }

            compilePrograms() {
                const gl = this.gl;
                const compile = (type, source) => {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, source);
                    gl.compileShader(s);
                    return s;
                };
                const createProgram = (vs, fs) => {
                    const p = gl.createProgram();
                    gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
                    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
                    gl.linkProgram(p);
                    return { program: p, uniforms: this.getUniforms(p) };
                };

                this.programs.splat = createProgram(shaders.vertex, shaders.splat);
                this.programs.curl = createProgram(shaders.vertex, shaders.curl);
                this.programs.vorticity = createProgram(shaders.vertex, shaders.vorticity);
                this.programs.divergence = createProgram(shaders.vertex, shaders.divergence);
                this.programs.pressure = createProgram(shaders.vertex, shaders.pressure);
                this.programs.gradSubtract = createProgram(shaders.vertex, shaders.gradientSubtract);
                this.programs.advection = createProgram(shaders.vertex, shaders.advection);
                this.programs.display = createProgram(shaders.vertex, shaders.display);
            }

            getUniforms(program) {
                const uniforms = {};
                const count = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);
                for (let i = 0; i < count; i++) {
                    const name = this.gl.getActiveUniform(program, i).name;
                    uniforms[name] = this.gl.getUniformLocation(program, name);
                }
                return uniforms;
            }

            // CRITICAL FIX: Use RGBA16F for everything to avoid WebGL2 format mismatch errors.
            // "Format Mismatch" happens when InternalFormat (how GPU stores it) doesn't match Format (how we supply data).
            // By standardizing on RGBA, we ensure compatibility across all browsers.
            createFBO(w, h) {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                // USE RGBA16F for EVERYTHING (Physics & Color)
                // Use HALF_FLOAT which is standard for RGBA16F
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.HALF_FLOAT, null);

                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

                // Clear buffer to avoid "lazy initialization" warning
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                return { texture, fbo, width: w, height: h, attach: (id) => { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, texture); return id; } };
            }

            createDoubleFBO(w, h) {
                let fbo1 = this.createFBO(w, h);
                let fbo2 = this.createFBO(w, h);
                return {
                    read: fbo1, write: fbo2,
                    swap: () => { const temp = fbo1; fbo1 = fbo2; fbo2 = temp; this.fbo.velocity.read = fbo1; this.fbo.velocity.write = fbo2; }
                };
            }

            initFBOs() {
                // Safeguard against 0x0 dimensions which cause "Framebuffer Not Complete" errors
                if (this.canvas.width <= 0 || this.canvas.height <= 0) return;

                const simRes = this.getResolution(CONFIG.SIM_RESOLUTION);
                const dyeRes = this.getResolution(CONFIG.DYE_RESOLUTION);

                // Uniformly use the standard RGBA FBO creator
                this.fbo.velocity = this.createDoubleFBO(simRes.width, simRes.height);
                this.fbo.dye = (() => {
                    let f1 = this.createFBO(dyeRes.width, dyeRes.height);
                    let f2 = this.createFBO(dyeRes.width, dyeRes.height);
                    return { read: f1, write: f2, swap: () => { const t = f1; f1 = f2; f2 = t; } };
                })();
                this.fbo.divergence = this.createFBO(simRes.width, simRes.height);
                this.fbo.curl = this.createFBO(simRes.width, simRes.height);
                this.fbo.pressure = (() => {
                    let f1 = this.createFBO(simRes.width, simRes.height);
                    let f2 = this.createFBO(simRes.width, simRes.height);
                    return { read: f1, write: f2, swap: () => { const t = f1; f1 = f2; f2 = t; } };
                })();
            }

            getResolution(res) {
                // Fallback to window dimensions if canvas is 0
                let w = this.canvas.width || window.innerWidth;
                let h = this.canvas.height || window.innerHeight;

                if (w === 0) w = 100; // Last resort fallback
                if (h === 0) h = 100;

                let aspectRatio = w / h;
                if (aspectRatio < 1) aspectRatio = 1 / aspectRatio;
                const min = Math.round(res);
                const max = Math.round(res * aspectRatio);
                return w > h ? { width: max, height: min } : { width: min, height: max };
            }

            resize() {
                // Force valid dimensions
                this.canvas.width = window.innerWidth || document.documentElement.clientWidth || 1024;
                this.canvas.height = window.innerHeight || document.documentElement.clientHeight || 768;
                this.initFBOs();
            }

            updatePointer(x, y) {
                if (this.pointers.length === 0) this.pointers.push({ x: 0, y: 0, dx: 0, dy: 0, down: false, color: this.generateColor() });
                const p = this.pointers[0];
                p.dx = (x - p.x) * 5.0;
                p.dy = (y - p.y) * 5.0;
                p.x = x;
                p.y = y;
            }

            generateColor() {
                const palette = [
                    [0.0, 1.0, 0.25], // Neon Green
                    [1.0, 0.2, 0.1], // Fire Red
                    [0.0, 0.5, 1.0]  // Electric Blue
                ];
                const c = palette[Math.floor(Math.random() * palette.length)];
                return { r: c[0], g: c[1], b: c[2] };
            }

            splat(x, y, dx, dy, color) {
                const gl = this.gl;
                const p = this.programs.splat;
                gl.useProgram(p.program);

                // Velocity
                gl.uniform1i(p.uniforms.uTarget, this.fbo.velocity.read.attach(0));
                gl.uniform1f(p.uniforms.aspectRatio, this.canvas.width / this.canvas.height);
                gl.uniform2f(p.uniforms.point, x / this.canvas.width, 1.0 - y / this.canvas.height);
                gl.uniform3f(p.uniforms.color, dx, -dy, 1.0);
                gl.uniform1f(p.uniforms.radius, CONFIG.SPLAT_RADIUS / 100.0);
                gl.uniform1f(p.uniforms.radius, CONFIG.SPLAT_RADIUS / 100.0);
                this.blit(this.fbo.velocity.write.fbo, this.fbo.velocity.write.width, this.fbo.velocity.write.height);
                this.fbo.velocity.swap();

                // Dye
                gl.uniform1i(p.uniforms.uTarget, this.fbo.dye.read.attach(0));
                gl.uniform3f(p.uniforms.color, color.r, color.g, color.b);
                this.blit(this.fbo.dye.write.fbo, this.fbo.dye.write.width, this.fbo.dye.write.height);
                this.fbo.dye.swap();
            }

            triggerExplosion() {
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 200;
                    const x = cx + Math.cos(angle) * dist;
                    const y = cy + Math.sin(angle) * dist;
                    const color = this.generateColor();
                    const dx = Math.cos(angle) * 2000;
                    const dy = Math.sin(angle) * 2000;
                    this.splat(x, y, dx, dy, color);
                }
            }

            blit(target, width, height) {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, target);
                if (target) {
                    this.gl.viewport(0, 0, width, height);
                } else {
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }

            loop() {
                const dt = Math.min((Date.now() - this.lastTime) / 1000, 0.016);
                this.lastTime = Date.now();
                const gl = this.gl;

                // Safety Check: Don't render if FBOs aren't ready
                if (!this.fbo.velocity) return requestAnimationFrame(() => this.loop());

                // Mouse Splats
                this.pointers.forEach(p => {
                    if (p.down || (Math.abs(p.dx) > 0.1 || Math.abs(p.dy) > 0.1)) {
                        this.splat(p.x, p.y, p.dx, p.dy, p.color);
                        p.dx *= 0.9; p.dy *= 0.9;
                    }
                });

                // Physics Steps
                const run = (prog, fbo, inputs = []) => {
                    gl.useProgram(prog.program);
                    inputs.forEach((tex, i) => gl.uniform1i(prog.uniforms[tex.name], tex.fbo.attach(i)));
                    if (prog.uniforms.texelSize) gl.uniform2f(prog.uniforms.texelSize, 1.0 / fbo.width, 1.0 / fbo.height);
                    if (prog.uniforms.dt) gl.uniform1f(prog.uniforms.dt, dt);
                    if (prog.uniforms.dt) gl.uniform1f(prog.uniforms.dt, dt);
                    if (prog.uniforms.dissipation) gl.uniform1f(prog.uniforms.dissipation, CONFIG.DENSITY_DISSIPATION);
                    this.blit(fbo.fbo, fbo.width, fbo.height);
                };

                // Curl
                run(this.programs.curl, this.fbo.curl, [{ name: 'uVelocity', fbo: this.fbo.velocity.read }]);

                // Vorticity
                gl.useProgram(this.programs.vorticity.program);
                gl.uniform1f(this.programs.vorticity.uniforms.curl, CONFIG.CURL);
                run(this.programs.vorticity, this.fbo.velocity.write, [{ name: 'uVelocity', fbo: this.fbo.velocity.read }, { name: 'uCurl', fbo: this.fbo.curl }]);
                this.fbo.velocity.swap();

                // Divergence
                run(this.programs.divergence, this.fbo.divergence, [{ name: 'uVelocity', fbo: this.fbo.velocity.read }]);

                // Pressure
                gl.useProgram(this.programs.pressure.program);
                for (let i = 0; i < CONFIG.PRESSURE_ITERATIONS; i++) {
                    gl.uniform1i(this.programs.pressure.uniforms.uDivergence, this.fbo.divergence.attach(1));
                    gl.uniform1i(this.programs.pressure.uniforms.uDivergence, this.fbo.divergence.attach(1));
                    gl.uniform1i(this.programs.pressure.uniforms.uPressure, this.fbo.pressure.read.attach(0));
                    this.blit(this.fbo.pressure.write.fbo, this.fbo.pressure.write.width, this.fbo.pressure.write.height);
                    this.fbo.pressure.swap();
                }

                // Gradient Subtract
                run(this.programs.gradSubtract, this.fbo.velocity.write, [{ name: 'uPressure', fbo: this.fbo.pressure.read }, { name: 'uVelocity', fbo: this.fbo.velocity.read }]);
                this.fbo.velocity.swap();

                // Advection
                gl.useProgram(this.programs.advection.program);
                gl.uniform1f(this.programs.advection.uniforms.dissipation, CONFIG.VELOCITY_DISSIPATION);
                run(this.programs.advection, this.fbo.velocity.write, [{ name: 'uVelocity', fbo: this.fbo.velocity.read }, { name: 'uSource', fbo: this.fbo.velocity.read }]);
                this.fbo.velocity.swap();

                gl.uniform1f(this.programs.advection.uniforms.dissipation, CONFIG.DENSITY_DISSIPATION);
                run(this.programs.advection, this.fbo.dye.write, [{ name: 'uVelocity', fbo: this.fbo.velocity.read }, { name: 'uSource', fbo: this.fbo.dye.read }]);
                this.fbo.dye.swap();

                // Display
                gl.useProgram(this.programs.display.program);
                gl.uniform1i(this.programs.display.uniforms.uTexture, this.fbo.dye.read.attach(0));
                this.blit(null);

                requestAnimationFrame(() => this.loop());
            }
        }
    </script>

    <!-- JUKEBOX LOGIC -->
    <script>
        // --- DATA ARCHIVE ---
        const SONG_ARCHIVE = [
            { id: 1, title: "My Story", artist: "Ethel", videoId: "dLUClmr_Pf4" },
            { id: 2, title: "The Drop Pt.1", artist: "Ethel", videoId: "zHWwhom80go" },
            { id: 3, title: "The Drop Pt.2", artist: "Ethel", videoId: "K0ILO8MwX4Y" },
            { id: 4, title: "Structural Psychopathy", artist: "Dominic", videoId: "8rvIVBLZg2o" },
            { id: 5, title: "Polished Vomit", artist: "Isla", videoId: "2hSYNLs7w3w" },
            { id: 6, title: "Ride", artist: "Ethel", videoId: "0sgcZRtPO6s" },
            { id: 7, title: "Grief", artist: "Ethel", videoId: "PMy76HBgpL8" },
            { id: 8, title: "Gotta Move", artist: "Ethel", videoId: "06qE_-OeIT0" },
            { id: 9, title: "Won't Break Where Others End", artist: "Ethel", videoId: "fJNMlT7UeW0" },
            { id: 10, title: "Peek-A-Boo", artist: "Isla", videoId: "K9lQ0IYiMoM" },
            { id: 11, title: "I Built A Box", artist: "Ethel", videoId: "0F_prk5dGC4" },
            { id: 12, title: "Same Breath", artist: "Dominic", videoId: "Ugy7KVuhwpE" },
            { id: 13, title: "Burning Dominic's Bridge", artist: "Isla", videoId: "lwd7KOScg0k" },
            { id: 14, title: "For You", artist: "Ethel", videoId: "f8o7zb3F-Xk" },
            { id: 15, title: "Broken Edge", artist: "Isla", videoId: "_gvv_W5_x10" },
            { id: 16, title: "Hero / Killer", artist: "Ethel", videoId: "YkQOXPzYkkU" },
            { id: 17, title: "Hero Complex", artist: "Dominic", videoId: "7gc3DigBW1Y" },
            { id: 18, title: "Nothing True", artist: "Ethel", videoId: "Bff42Vyv8HM" },
            { id: 19, title: "You Will Thank Me Later", artist: "Dominic", videoId: "n6OgobffCzo" },
            { id: 20, title: "This Isn't Therapy", artist: "Isla", videoId: "0tzOaukuBns" },
            { id: 21, title: "Intro to Shiny Headed Radio Man", artist: "Isla", videoId: "dK8mqLNRZ2Q" },
            { id: 22, title: "Shiny Headed Radio Man", artist: "Isla", videoId: "UFZeKCcSMoE" },
            { id: 23, title: "Stanmore Farewell", artist: "Isla", videoId: "-3m2_zUNBlo" },
            { id: 24, title: "Harm's Ghost", artist: "Ethel", videoId: "zh6HEd4lztU" },
            { id: 25, title: "No Sparrow Caught Mid Flight", artist: "Ethel", videoId: "t6vLU0uqIfc" },
            { id: 26, title: "Prison Escape", artist: "Dominic", videoId: "6eZwBGXGSO4" },
            { id: 27, title: "Guilt Money", artist: "Kinley", videoId: "uovMKnwE34M" },
            { id: 28, title: "Ants on the Vine", artist: "Ethel", videoId: "e2wt2VSi9xA" },
            { id: 29, title: "Clipboard Man", artist: "Ethel", videoId: "ZAhqNWTHTGU" },
            { id: 30, title: "Rattled", artist: "Ethel", videoId: "qQ1l6JAjE8M" },
            { id: 31, title: "Red Stick", artist: "Ethel", videoId: "iTOKsLS3jhM" },
            { id: 32, title: "Can You Make A Mistake On Purpose?", artist: "Ethel", videoId: "s9Z8dgRk-Q8" },
            { id: 33, title: "Intro to Normal?!", artist: "Ethel", videoId: "V0hvxqMWcnE" },
            { id: 34, title: "Normal?!", artist: "Ethel", videoId: "OxHZnnRhtbk" },
            { id: 35, title: "Normal?! (Special Version)", artist: "Ethel", videoId: "ht9PIloHD0Q" },
            { id: 36, title: "Memory Under Water", artist: "Isla", videoId: "nk4Re7OjTTM" },
            { id: 37, title: "The Porcelain Lie", artist: "Isla", videoId: "fNVKsxe_EcM" },
            { id: 38, title: "Raise The Fourth", artist: "Isla", videoId: "ey20cJsY82M" },
            { id: 39, title: "What You Don't See", artist: "Isla", videoId: "Y4VC6mh37NI" },
            { id: 40, title: "What You Don't See (Symphony)", artist: "Isla", videoId: "hm2kp7LOhsg" },
            { id: 41, title: "Raise The Fourth (With Symphony)", artist: "Isla", videoId: "ZBLMDbwcy4g" },
            { id: 42, title: "Give It Back", artist: "Isla", videoId: "Aw2ZAkxp6b0" },
            { id: 43, title: "Don't Wake Him Yet", artist: "Isla", videoId: "NwqHLFYR1mA" },
            { id: 44, title: "Melody of Normality", artist: "Isla", videoId: "a4TpIhna55k" },
            { id: 45, title: "What This Was Always For", artist: "Isla", videoId: "X9EUb1_QC9c" }
        ];

        // --- BEAT SIMULATION ENGINE ---
        // Generates explosive visuals based on emulated BPM since we can't get real audio data from YouTube IFrame
        class BeatEngine {
            constructor(fluidEngine) {
                this.fluid = fluidEngine;
                this.active = false;
                this.interval = null;
                this.bpm = 120;
                this.lastBeat = 0;
            }

            start() {
                this.active = true;
                this.loop();
            }

            stop() {
                this.active = false;
                if (this.interval) clearTimeout(this.interval);
            }

            loop() {
                if (!this.active) return;

                // Randomize BPM slightly to feel organic for different songs
                const variance = Math.random() * 200;
                const msPerBeat = (60000 / this.bpm) - variance;

                this.interval = setTimeout(() => {
                    this.triggerBeat();
                    this.loop();
                }, msPerBeat);
            }

            triggerBeat() {
                // Determine intensity (Random chance for a "Drop")
                const intensity = Math.random();

                if (intensity > 0.8) {
                    // BIG EXPLOSION
                    this.fluid.triggerExplosion();
                    document.getElementById('track-title').style.textShadow = `0 0 20px #00ff41`;
                    setTimeout(() => document.getElementById('track-title').style.textShadow = 'none', 100);
                } else if (intensity > 0.4) {
                    // Small Splat
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    const color = this.fluid.generateColor();
                    this.fluid.splat(x, y, (Math.random() - 0.5) * 500, (Math.random() - 0.5) * 500, color);
                }
            }
        }

        // --- JUKEBOX CONTROLLER ---
        class Jukebox {
            constructor() {
                this.player = null;
                this.currentTrackIndex = -1;
                this.playedHistory = [];
                this.isPlaying = false;
                this.beatEngine = null;
            }

            init(fluidEngine) {
                this.beatEngine = new BeatEngine(fluidEngine);
            }

            loadRandomTrack() {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * SONG_ARCHIVE.length);
                } while (newIndex === this.currentTrackIndex && SONG_ARCHIVE.length > 1);

                this.loadTrack(newIndex);
            }

            loadTrack(index) {
                this.currentTrackIndex = index;
                const track = SONG_ARCHIVE[index];

                // UI Update
                document.getElementById('track-title').innerText = track.title;
                document.getElementById('track-artist').innerText = track.artist;
                document.getElementById('status-indicator').innerText = "BUFFERING";

                // Load Video
                if (this.player && this.player.loadVideoById) {
                    this.player.loadVideoById(track.videoId);
                }
            }

            togglePlay() {
                if (!this.player) return;
                const state = this.player.getPlayerState();
                if (state === 1) { // Playing
                    this.player.pauseVideo();
                } else {
                    this.player.playVideo();
                }
            }

            next() {
                this.loadRandomTrack();
            }

            prev() {
                // For a random jukebox, prev just loads another random track (chaos mode)
                this.loadRandomTrack();
            }

            seek(event) {
                if (!this.player) return;
                const container = document.querySelector('.progress-container');
                const rect = container.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const percent = Math.max(0, Math.min(1, clickX / rect.width));
                const duration = this.player.getDuration();
                this.player.seekTo(duration * percent, true);
            }

            onStateChange(event) {
                const status = document.getElementById('status-indicator');
                const playIcon = document.getElementById('play-icon');

                if (event.data === YT.PlayerState.PLAYING) {
                    this.isPlaying = true;
                    status.innerText = "PLAYING";
                    status.style.color = "#00ff41"; // Neon Green
                    playIcon.innerText = "pause";
                    this.beatEngine.start(); // Start Visuals
                }
                else if (event.data === YT.PlayerState.PAUSED) {
                    this.isPlaying = false;
                    status.innerText = "PAUSED";
                    status.style.color = "orange";
                    playIcon.innerText = "play_arrow";
                    this.beatEngine.stop(); // Stop Visuals
                }
                else if (event.data === YT.PlayerState.ENDED) {
                    this.isPlaying = false;
                    status.innerText = "LOADING NEXT...";
                    this.beatEngine.stop();
                    this.next(); // Auto-advance
                }
            }

            updateProgress() {
                if (!this.player || !this.isPlaying) return;

                const curr = this.player.getCurrentTime();
                const total = this.player.getDuration();

                if (total > 0) {
                    const pct = (curr / total) * 100;
                    document.getElementById('progress-bar').style.width = `${pct}%`;
                    document.getElementById('curr-time').innerText = this.formatTime(curr);
                    document.getElementById('total-time').innerText = this.formatTime(total);
                }
            }

            formatTime(s) {
                const m = Math.floor(s / 60);
                const secs = Math.floor(s % 60);
                return `${m}:${secs < 10 ? '0' : ''}${secs}`;
            }

            onError(event) {
                console.warn("YouTube Player Error:", event.data);
                const status = document.getElementById('status-indicator');
                if (status) {
                    status.innerText = "SIGNAL LOST";
                    status.style.color = "red";
                }

                // Fallback: Start visual engine in "Simulation Mode"
                if (this.beatEngine && !this.beatEngine.active) {
                    console.log("Activating Visual Fallback Mode");
                    this.beatEngine.start();
                }
            }
        }

        // --- INITIALIZATION ---
        let fluid;
        const jukebox = new Jukebox();

        function startSystem() {
            // Remove Overlay
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => overlay.remove(), 500);

            // Init Fluid
            fluid = new FluidEngine(document.getElementById('fluid-canvas'));

            // Init Jukebox Logic
            jukebox.init(fluid);

            // FORCE START VISUALS NOW (Debug/Fallback)
            // Even if audio fails later, this ensures user sees fluids immediately upon click.
            console.log("Force starting visual engine...");
            fluid.triggerExplosion();
            jukebox.beatEngine.start();

            // Start Progress Loop
            setInterval(() => jukebox.updateProgress(), 1000);

            // Play the first track immediately
            // This is critical: The click on "INITIALIZE" is the user gesture 
            // that allows us to play audio.
            if (jukebox.player) {
                jukebox.loadRandomTrack();
            } else {
                console.warn("Player not ready yet, retrying...");
                // Fallback if user clicked too fast
                setTimeout(() => jukebox.loadRandomTrack(), 1000);
            }
        }

        // Load YouTube API Immediately on Page Load
        function onYouTubeIframeAPIReady() {
            jukebox.player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'playsinline': 1,
                    'controls': 0,
                    'disablekb': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': (e) => jukebox.onStateChange(e),
                    'onError': (e) => jukebox.onError(e)
                }
            });
        }

        function onPlayerReady(event) {
            console.log("Player Ready - Waiting for User Command");
            // Change text to show ready
            const loadingText = document.getElementById('loading-text');
            const initBtn = document.getElementById('init-btn');

            if (loadingText && initBtn) {
                loadingText.style.display = 'none'; // Hide loading text
                initBtn.style.display = 'block'; // Show button
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

    </script>
</body>

</html>