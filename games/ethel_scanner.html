<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ETHEL // FREQUENCY SCANNER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Space+Grotesk:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap"
        rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" />

    <style>
        :root {
            --neon-green: #00ff41;
            --neon-dim: rgba(0, 255, 65, 0.1);
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            color: #e0e0e0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            user-select: none;
            cursor: none;
            /* We use a custom cursor */
        }

        /* --- CRT EFFECT --- */
        .scanlines {
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0),
                    rgba(255, 255, 255, 0) 50%,
                    rgba(0, 0, 0, 0.2) 50%,
                    rgba(0, 0, 0, 0.2));
            background-size: 100% 4px;
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }

        .crt-flicker {
            animation: flicker 0.15s infinite;
            pointer-events: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 255, 65, 0.02);
            z-index: 49;
            opacity: 0.5;
        }

        @keyframes flicker {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 0.55;
            }

            100% {
                opacity: 0.5;
            }
        }

        /* --- UI ELEMENTS --- */
        .hud-text {
            font-family: 'Share Tech Mono', monospace;
            text-shadow: 0 0 5px var(--neon-green);
        }

        .node-label {
            position: absolute;
            font-family: 'Courier Prime', monospace;
            font-size: 10px;
            color: var(--neon-green);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            transform: translate(-50%, -20px);
            z-index: 20;
            text-shadow: 0 0 4px black;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border: 1px solid var(--neon-green);
        }

        /* --- CUSTOM CURSOR --- */
        #scanner-reticle {
            position: fixed;
            top: 0;
            left: 0;
            width: 80px;
            height: 80px;
            border: 1px dashed rgba(0, 255, 65, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            transition: width 0.2s, height 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #scanner-reticle::after {
            content: '';
            width: 4px;
            height: 4px;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
        }

        #scanner-reticle.locked {
            border-style: solid;
            border-color: var(--neon-green);
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 65, 0.05);
            animation: pulse-lock 1s infinite;
        }

        @keyframes pulse-lock {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 255, 65, 0.4);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(0, 255, 65, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 255, 65, 0);
            }
        }

        /* --- START OVERLAY --- */
        #start-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .glitch-text {
            position: relative;
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }

        @keyframes glitch-skew {
            0% {
                transform: skew(0deg);
            }

            20% {
                transform: skew(-2deg);
            }

            40% {
                transform: skew(2deg);
            }

            60% {
                transform: skew(-1deg);
            }

            80% {
                transform: skew(1deg);
            }

            100% {
                transform: skew(0deg);
            }
        }

        .log-entry {
            border-left: 2px solid #333;
            padding-left: 10px;
            margin-bottom: 8px;
            font-size: 11px;
            opacity: 0.6;
            transition: all 0.5s;
        }

        .log-entry.active {
            border-left-color: var(--neon-green);
            opacity: 1;
            color: var(--neon-green);
        }
    </style>
</head>

<body>

    <!-- VISUAL LAYERS -->
    <div class="scanlines"></div>
    <div class="crt-flicker"></div>

    <!-- CANVAS FOR NODES & LINES -->
    <canvas id="mainCanvas" class="absolute inset-0 w-full h-full z-10"></canvas>

    <!-- CUSTOM CURSOR -->
    <div id="scanner-reticle">
        <div class="absolute -top-6 text-[10px] text-green-500/50 font-mono tracking-widest" id="cursor-coords">000.000
        </div>
    </div>

    <!-- HUD -->
    <div class="fixed top-0 left-0 w-full p-4 z-40 pointer-events-none flex justify-between items-start">
        <div>
            <h1 class="text-2xl font-bold text-white tracking-widest hud-text glitch-text">PIXELSTORTION</h1>
            <div class="text-xs text-green-500 font-mono mt-1">FREQUENCY SCANNER v2.4 // ETHEL_SOURCE</div>
        </div>
        <div class="text-right">
            <div class="text-xs text-gray-500 font-mono">FRAGMENTS RECOVERED</div>
            <div class="text-xl text-green-500 font-mono" id="score-display">0 / 72</div>
        </div>
    </div>

    <!-- SUBTITLE CONTAINER -->
    <div class="fixed bottom-20 left-0 w-full text-center z-40 pointer-events-none px-4">
        <div id="subtitle-box"
            class="inline-block bg-black/80 border border-green-900 px-6 py-4 backdrop-blur-sm hidden">
            <p id="subtitle-text"
                class="text-green-400 font-mono text-lg md:text-xl tracking-wide uppercase typing-effect"></p>
        </div>
    </div>

    <!-- SIDEBAR LOG (Desktop) -->
    <div
        class="fixed top-24 right-4 w-64 bottom-24 overflow-hidden z-30 pointer-events-none hidden md:flex flex-col items-end">
        <div id="log-container" class="w-full text-right font-mono text-gray-400">
            <!-- Logs appear here -->
        </div>
    </div>

    <!-- START OVERLAY -->
    <div id="start-overlay">
        <div class="text-green-500 text-6xl mb-4 material-symbols-outlined animate-pulse">fingerprint</div>
        <h2 class="text-white text-2xl font-bold tracking-[0.5em] mb-2 font-mono glitch-text">SYSTEM LOCKED</h2>
        <p class="text-green-500/50 text-sm font-mono tracking-widest">[ CLICK TO INITIALIZE SCANNER ]</p>
    </div>

    <script>
        // --- CONFIGURATION ---

        // Change this if you upload files to a different folder structure.
        // Points to the R2 bucket Ethel_speaks folder
        const AUDIO_BASE_URL = 'https://pub-111e813bd5634cd8a9ecdd3d5c2a0916.r2.dev/Ethel_speaks/';

        // List of audio files and their transcripts
        // Organized by narrative phase - comprehensive Ethel corpus
        const AUDIO_DATA = [
            // === PHASE 0 - META INTRODUCTION ===
            { id: "e001", text: "Entry key for the whole corpus", file: "EthelRunIntroMonologue.mp3", phase: "Meta" },

            // === PHASE 0.5 - DOMINIC'S OPERATING PATTERNS (RETROSPECTIVE) ===
            { id: "e002", text: "They don't pause, they rewrite", file: "Ethel_they_dont_pause_they_rewrite.mp3", phase: "0.5" },
            { id: "e003", text: "Charisma - it's not", file: "Ethel_charisma_itsNot.mp3", phase: "0.5" },
            { id: "e004", text: "Charisma - it's nothing", file: "Ethel_charisma_itsNothh.mp3", phase: "0.5" },
            { id: "e005", text: "Confidence becomes routine", file: "Ethel_Confidence_becomes_routine.mp3", phase: "0.5" },
            { id: "e006", text: "Control dressed as calm", file: "Ethel_control_dressed_as_calm.mp3", phase: "0.5" },
            { id: "e007", text: "Gran had been", file: "Ethel_Gran_Had_been.mp3", phase: "0.5" },

            // === PHASE 1 - RURAL AUSTRALIA (PRE-LOSS) ===
            { id: "e008", text: "Home no more", file: "Ethel_Home_no_more.mp3", phase: "1" },
            { id: "e009", text: "Movement keeps me alive", file: "Ethel_movement_keeps_me_alive.mp3", phase: "1" },

            // === PHASE 1.5 - PARALLEL EVENT (THE WEDDING) ===
            { id: "e010", text: "Drop truth", file: "Ethel_Drop_truth.mp3", phase: "1.5" },
            { id: "e011", text: "Like a threat wrapped in ribbon", file: "Ethel_like_a_threat_wrapped_in_ribbon.mp3", phase: "1.5" },

            // === PHASE 2 - LOSS, DISCOVERY & LEGAL CHECKMATE ===
            { id: "e012", text: "Too normal", file: "Ethel_too_normal.mp3", phase: "2" },
            { id: "e013", text: "My name wrong", file: "Ethel_My_name_wrong.mp3", phase: "2" },
            { id: "e014", text: "Things that change you", file: "Ethel_Things_that_change_you.mp3", phase: "2" },
            { id: "e015", text: "After something breaks", file: "Ethel_After_something_breaks.mp3", phase: "2" },
            { id: "e016", text: "I wasn't allowed to", file: "Ethel_I_wasnt_allowed_to.mp3", phase: "2" },
            { id: "e017", text: "Dates, statements, omissions", file: "Ethel_dates_statements_ommisions.mp3", phase: "2" },
            { id: "e018", text: "Right to be careful", file: "Ethel_right_to_be_careful.mp3", phase: "2" },
            { id: "e019", text: "Map for a storm", file: "Ethel_Map_for_a_storm.mp3", phase: "2" },
            { id: "e020", text: "Red dirt ends", file: "Ethel_red_dirt_ends.mp3", phase: "2" },
            { id: "e021", text: "Here's the thing about no choice", file: "Ethel_hers_the_thing_about_no_choice.mp3", phase: "2" },

            // === PHASE 3 - FORCED ENTRY INTO DOMINIC'S WORLD ===
            { id: "e022", text: "The man sent to collect me", file: "Ethel_the_man_sent_to_collect_me.mp3", phase: "3" },
            { id: "e023", text: "Entering a system", file: "Ethel_entering_a_system.mp3", phase: "3" },
            { id: "e024", text: "A story told without sound", file: "Ethel_a_story_told_without_sound.mp3", phase: "3" },
            { id: "e025", text: "Pretending not to watch me", file: "Ethel_pretending_not_to_watch_me.mp3", phase: "3" },
            { id: "e026", text: "Narrow drive", file: "Ethel_Narow_drive.mp3", phase: "3" },
            { id: "e027", text: "Never raised his voice", file: "Ethel_never_raised_his_voice.mp3", phase: "3" },
            { id: "e028", text: "Routine", file: "Ethel_routine.mp3", phase: "3" },
            { id: "e029", text: "Politeness - the leash", file: "Ethel_politness_the_leash.mp3", phase: "3" },
            { id: "e030", text: "Pressure", file: "Ethel_pressure.mp3", phase: "3" },
            { id: "e031", text: "Until yours disappears", file: "Ethel_until_yours_disappears.mp3", phase: "3" },
            { id: "e032", text: "Doing them a favour", file: "Ethel_doing_them_a_favour.mp3", phase: "3" },
            { id: "e033", text: "Simple for him", file: "Ethel_simple_for_him.mp3", phase: "3" },
            { id: "e034", text: "Like he's simple", file: "Ethel_like_hes_simple.mp3", phase: "3" },
            { id: "e035", text: "Looked through me", file: "Ethel_looked_through_me.mp3", phase: "3" },
            { id: "e036", text: "Forget the gesture", file: "Ethel_Forget_the_gesture.mp3", phase: "3" },
            { id: "e037", text: "Got things done", file: "Ethel_Goth_things_done.mp3", phase: "3" },

            // === PHASE 3 - ISLA ALREADY INSIDE ===
            { id: "e038", text: "Isla was a different danger", file: "Ethel_Isla_was_a_different_danger.mp3", phase: "3" },
            { id: "e039", text: "Because it looked smug", file: "Ethel_because_it_looked_smug.mp3", phase: "3" },
            { id: "e040", text: "Plant, bait, boring", file: "Ethel_plant_bait_boring.mp3", phase: "3" },
            { id: "e041", text: "Two survival styles", file: "Ethel_two_survival_styles.mp3", phase: "3" },

            // === PHASE 3 - VIOLENCE INSIDE THE HOUSE ===
            { id: "e042", text: "Architecture", file: "Ethel_Archetecture.mp3", phase: "3" },
            { id: "e043", text: "Identifying with", file: "Ethel_Identifying_with.mp3", phase: "3" },
            { id: "e044", text: "Shortest route to staying alive", file: "Ethel_shortes_route_to_staying_alive.mp3", phase: "3" },
            { id: "e045", text: "Divided perfectly", file: "Ethel_divied_perfectly.mp3", phase: "3" },
            { id: "e046", text: "Shut off whole parts of themselves", file: "Ethel_shut_of_whole_parts_of_themselves.mp3", phase: "3" },
            { id: "e047", text: "Split reaction", file: "Ethel_split_reaction.mp3", phase: "3" },
            { id: "e048", text: "The way predators see limp", file: "Ethel_the_way_preditors_see_limp.mp3", phase: "3" },

            // === PHASE 3.5 - ISLA TARGETED / FIRST LEAK ===
            { id: "e049", text: "Blast radius", file: "Ethel_blast_radius.mp3", phase: "3.5" },
            { id: "e050", text: "Both truths at once", file: "Ethel_both_truths_at_once.mp3", phase: "3.5" },
            { id: "e051", text: "Nothing makes sense if you don't", file: "Ethel_nothing_makes_sense_if_you_dont.mp3", phase: "3.5" },

            // === PHASE 3.75 - ANGER / AGENCY REBOOT ===
            { id: "e052", text: "Point of a blade", file: "Ethel_point_of_a_blade.mp3", phase: "3.75" },

            // === PHASE 4 - BURN THE BRIDGE ===
            { id: "e053", text: "Isla locks them out", file: "isla_locks_them_out.mp3", phase: "4" },
            { id: "e054", text: "Isla had done her part", file: "Ethel_isla_had_done_her_part.mp3", phase: "4" },
            { id: "e055", text: "Court proof, not poetic", file: "Ethel_court_proof_not_poetic.mp3", phase: "4" },
            { id: "e056", text: "To notice who lit the fire", file: "Ethel_to_notice_who_lit_the_fire.mp3", phase: "4" },

            // === PHASE 5 - TRIAL & AFTERMATH ===
            { id: "e057", text: "Court proof", file: "Ethel_court_proof.mp3", phase: "5" },
            { id: "e058", text: "Because he won't stop", file: "Ethel_because_he_wont_stop.mp3", phase: "5" },
            { id: "e059", text: "A pulse nearby", file: "Ethel_a_pulse_near_by.mp3", phase: "5" },
            { id: "e060", text: "Without ever saying control", file: "Ethel_without-ever_saying_control.mp3", phase: "5" },

            // === PHASE 6 - THE FUTURE / NEXT CHAPTER ===
            { id: "e061", text: "Wasn't looking for trouble", file: "Ethel_wasnt_looking_for_trouble.mp3", phase: "6" },

            // === ADDITIONAL FRAGMENTS (CROSS-PHASE) ===
            { id: "e062", text: "Exactly what it looked like", file: "Ethel_exactly_what_it_looked_like.mp3", phase: "X" },
            { id: "e063", text: "Fallout came to me", file: "Ethel_fallout_came_to_me.mp3", phase: "X" },
            { id: "e064", text: "Hate, love - not clarifying", file: "Ethel_hate_love_not_clarifying.mp3", phase: "X" },
            { id: "e065", text: "Make a choice", file: "Ethel_make_a_choice.mp3", phase: "X" },
            { id: "e066", text: "Not contradiction", file: "Ethel_not_contradiction.mp3", phase: "X" },
            { id: "e067", text: "Or who didn't get backup", file: "Ethel_or_who_didnt_get_backup.mp3", phase: "X" },
            { id: "e068", text: "Pretend not to know", file: "Ethel_pretend_not_to_know.mp3", phase: "X" },
            { id: "e069", text: "Relief as currency", file: "Ethel_Relief_as_currency.mp3", phase: "X" },
            { id: "e070", text: "Rhythm is the weapon", file: "Ethel_rhythm_is_the_weapon.mp3", phase: "X" },
            { id: "e071", text: "Threat wrapped in ribbon", file: "Ethel_threat_wrapped_in_ribbon.mp3", phase: "X" },
            { id: "e072", text: "To notice who lit it", file: "Ethel_to_notice_who_lit_it.mp3", phase: "X" }
        ];



        // --- SYSTEM VARIABLES ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const reticle = document.getElementById('scanner-reticle');
        const cursorCoords = document.getElementById('cursor-coords');

        let nodes = [];
        let width, height;
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;

        // Audio
        let audioCtx;
        let activeAudio = null; // Currently playing HTML5 audio object
        let activeNodeIndex = -1;
        let isIdle = true;
        let idleTimer = null;
        let autoScanTarget = null; // Coordinates for auto-scan
        let lastInteractionTime = Date.now();

        // Constants
        const LOCK_DISTANCE = 50; // Pixels to trigger audio
        const CAPTURE_TIME = 2000; // ms to fully capture a node
        const IDLE_THRESHOLD = 8000; // ms before auto-pilot starts

        // --- INITIALIZATION ---

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // Reposition nodes if they go off screen, or just let them float
        }
        window.addEventListener('resize', resize);

        function initNodes() {
            nodes = AUDIO_DATA.map((data, index) => ({
                ...data,
                x: Math.random() * (window.innerWidth - 100) + 50,
                y: Math.random() * (window.innerHeight - 100) + 50,
                vx: (Math.random() - 0.5) * 0.2, // Drift velocity
                vy: (Math.random() - 0.5) * 0.2,
                discovered: false, // Has it been fully played?
                locked: false, // Is the cursor currently "locking" it?
                captureProgress: 0,
                audioObj: null // HTML5 Audio element
            }));

            // Pre-create audio objects to avoid lag
            nodes.forEach(node => {
                const a = new Audio(AUDIO_BASE_URL + node.file);
                a.volume = 0;
                // Loop slightly to help with capture, but we really want one-shot
                // Actually, let's make it loop while hovering, stop when leaving.
                // Upon capture, we play it fully once.
                node.audioObj = a;
            });

            updateScore();
        }

        // --- AUDIO ENGINE ---

        function handleAudioProximity(targetX, targetY) {
            let closestDist = Infinity;
            let closestNodeIndex = -1;

            nodes.forEach((node, index) => {
                const dist = Math.hypot(node.x - targetX, node.y - targetY);

                // If discovered, ignore for proximity audio (it's already logged)
                // Or maybe keeps playing? Let's say discovered nodes are silent or quiet ambient.

                if (dist < closestDist) {
                    closestDist = dist;
                    closestNodeIndex = index;
                }
            });

            // Logic for the closest node
            if (closestNodeIndex !== -1) {
                const node = nodes[closestNodeIndex];
                const maxDist = 200; // Radius where audio starts fading in

                if (closestDist < maxDist) {
                    // Calculate volume (0 to 1)
                    let vol = 1 - (closestDist / maxDist);
                    vol = Math.max(0, Math.min(1, vol * vol)); // curve it

                    // If this is a different node than active, switch
                    if (activeNodeIndex !== closestNodeIndex) {
                        // Fade out old
                        if (activeNodeIndex !== -1) {
                            fadeOut(nodes[activeNodeIndex].audioObj);
                        }

                        // Start new if not playing
                        node.audioObj.currentTime = 0;
                        node.audioObj.loop = true; // Loop while hovering to allow "tuning"
                        node.audioObj.play().catch(e => console.log("Play error", e));
                        activeNodeIndex = closestNodeIndex;
                    }

                    // Set volume
                    node.audioObj.volume = vol;

                    // Check for LOCKING (Center hit)
                    if (closestDist < LOCK_DISTANCE && !node.discovered) {
                        reticle.classList.add('locked');
                        node.captureProgress += 0.01; // Increment per frame

                        // Show subtitle preview (glitched)
                        showSubtitle(node.text, true);

                        if (node.captureProgress >= 1) {
                            captureNode(closestNodeIndex);
                        }
                    } else {
                        reticle.classList.remove('locked');
                        hideSubtitle();
                    }

                } else {
                    // Too far from any node
                    if (activeNodeIndex !== -1) {
                        fadeOut(nodes[activeNodeIndex].audioObj);
                        activeNodeIndex = -1;
                    }
                    reticle.classList.remove('locked');
                    hideSubtitle();
                }
            }
        }

        function fadeOut(audio) {
            if (!audio) return;
            const fade = setInterval(() => {
                if (audio.volume > 0.05) {
                    audio.volume -= 0.05;
                } else {
                    audio.volume = 0;
                    audio.pause();
                    audio.loop = false;
                    clearInterval(fade);
                }
            }, 50);
        }

        function captureNode(index) {
            const node = nodes[index];
            node.discovered = true;
            node.captureProgress = 1;

            // Play fully clearly ONCE
            node.audioObj.loop = false;
            node.audioObj.currentTime = 0;
            node.audioObj.volume = 1;
            node.audioObj.play();

            // Visual feedback
            updateScore();
            showSubtitle(node.text, false); // Clear text
            addToLog(node.text);

            // Flash screen
            const flash = document.createElement('div');
            flash.className = 'fixed inset-0 bg-green-500 z-50 pointer-events-none';
            flash.style.opacity = '0.2';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);
        }

        // --- UI UPDATES ---

        function showSubtitle(text, isGlitching) {
            const box = document.getElementById('subtitle-box');
            const el = document.getElementById('subtitle-text');
            box.classList.remove('hidden');

            if (isGlitching) {
                // Randomize some characters
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*";
                const glitched = text.split('').map(c => Math.random() > 0.7 ? chars[Math.floor(Math.random() * chars.length)] : c).join('');
                el.innerText = glitched;
                el.style.opacity = 0.7;
            } else {
                el.innerText = text;
                el.style.opacity = 1;
            }
        }

        function hideSubtitle() {
            // Only hide if we aren't listening to a discovered node finish playing
            const activeNode = activeNodeIndex !== -1 ? nodes[activeNodeIndex] : null;
            if (activeNode && activeNode.discovered && !activeNode.audioObj.paused) return;

            document.getElementById('subtitle-box').classList.add('hidden');
        }

        function addToLog(text) {
            const container = document.getElementById('log-container');
            const entry = document.createElement('div');
            entry.className = 'log-entry active';
            entry.innerText = `>> ${text.substring(0, 25)}...`;
            container.prepend(entry); // Newest top
        }

        function updateScore() {
            const count = nodes.filter(n => n.discovered).length;
            document.getElementById('score-display').innerText = `${count} / ${nodes.length}`;
        }

        // --- RENDER LOOP ---

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Draw connections between discovered nodes
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 255, 65, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < nodes.length; i++) {
                if (!nodes[i].discovered) continue;
                for (let j = i + 1; j < nodes.length; j++) {
                    if (nodes[j].discovered) {
                        // Draw line
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                    }
                }
            }
            ctx.stroke();

            // Draw Nodes
            nodes.forEach(node => {
                // Update physics
                node.x += node.vx;
                node.y += node.vy;

                // Bounce off walls
                if (node.x < 0 || node.x > width) node.vx *= -1;
                if (node.y < 0 || node.y > height) node.vy *= -1;

                const isVisible = node.discovered;

                if (isVisible) {
                    // Discovered Node: Bright Green Square
                    ctx.fillStyle = '#00ff41';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff41';
                    ctx.fillRect(node.x - 3, node.y - 3, 6, 6);
                    ctx.shadowBlur = 0;
                } else {
                    // Hidden Node: Faint static or invisible
                    // We only draw it if close to cursor for "hint"
                    // Get distance to CURRENT INTERACTION POINT (Mouse or Auto)
                    const targetX = isIdle ? (autoScanTarget ? autoScanTarget.x : -1000) : mouseX;
                    const targetY = isIdle ? (autoScanTarget ? autoScanTarget.y : -1000) : mouseY;

                    const dist = Math.hypot(node.x - targetX, node.y - targetY);

                    if (dist < 200) {
                        // Draw faint ring
                        const opacity = 1 - (dist / 200);
                        ctx.strokeStyle = `rgba(0, 255, 65, ${opacity * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 5 + Math.random() * 5, 0, Math.PI * 2);
                        ctx.stroke();

                        // Glitch line
                        if (Math.random() > 0.9) {
                            ctx.fillStyle = `rgba(0, 255, 65, ${opacity})`;
                            ctx.fillRect(node.x - 10, node.y, 20, 1);
                        }
                    }
                }
            });

            // Auto Scan Logic
            updateAutoPilot();

            requestAnimationFrame(draw);
        }

        // --- INPUT HANDLING ---

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            reticle.style.left = mouseX + 'px';
            reticle.style.top = mouseY + 'px';
            cursorCoords.innerText = `${mouseX.toString().padStart(4, '0')}.${mouseY.toString().padStart(4, '0')}`;

            // Reset Idle
            lastInteractionTime = Date.now();
            isIdle = false;
            autoScanTarget = null;

            // Process Audio
            handleAudioProximity(mouseX, mouseY);
        });

        // Touch support
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            reticle.style.left = mouseX + 'px';
            reticle.style.top = mouseY + 'px';

            lastInteractionTime = Date.now();
            isIdle = false;

            handleAudioProximity(mouseX, mouseY);
        }, { passive: false });


        // --- AUTO PILOT (IDLE STATE) ---

        function updateAutoPilot() {
            if (Date.now() - lastInteractionTime > IDLE_THRESHOLD) {
                isIdle = true;

                // If we don't have a target, pick the nearest UNDISCOVERED node
                if (!autoScanTarget) {
                    // Find random undiscovered
                    const available = nodes.filter(n => !n.discovered);
                    if (available.length > 0) {
                        const targetNode = available[Math.floor(Math.random() * available.length)];
                        autoScanTarget = {
                            x: targetNode.x,
                            y: targetNode.y,
                            node: targetNode,
                            currentX: mouseX, // Start from current mouse pos
                            currentY: mouseY
                        };
                    } else {
                        // All found, just drift to center
                        autoScanTarget = { x: width / 2, y: height / 2, currentX: mouseX, currentY: mouseY };
                    }
                }

                // Move virtual cursor towards target
                const dx = autoScanTarget.x - autoScanTarget.currentX;
                const dy = autoScanTarget.y - autoScanTarget.currentY;

                // Ease movement
                autoScanTarget.currentX += dx * 0.02;
                autoScanTarget.currentY += dy * 0.02;

                // Move visuals
                reticle.style.left = autoScanTarget.currentX + 'px';
                reticle.style.top = autoScanTarget.currentY + 'px';
                reticle.style.borderColor = 'rgba(255, 255, 255, 0.5)'; // White reticle for auto-pilot
                cursorCoords.innerText = "AUTO-SCANNING...";

                // Trigger audio logic with VIRTUAL coordinates
                handleAudioProximity(autoScanTarget.currentX, autoScanTarget.currentY);

                // If we are super close, pick a new target after a while
                if (Math.hypot(dx, dy) < 10) {
                    // Let it sit for a second (handled by capture logic), then reset target to null to pick new one
                    // But capture logic happens inside handleAudioProximity
                    if (autoScanTarget.node && autoScanTarget.node.discovered) {
                        // Move to next
                        setTimeout(() => { autoScanTarget = null; }, 2000);
                    }
                }
            } else {
                reticle.style.borderColor = ''; // Reset color
            }
        }

        // --- STARTUP ---

        document.getElementById('start-overlay').addEventListener('click', () => {
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = 0;
            setTimeout(() => overlay.remove(), 1000);

            // Init
            resize();
            initNodes();
            draw();

            // Play a startup sound or unlock audio context
            // Just playing a silent buffer or getting context ready
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            audioCtx.resume();
        });

    </script>
</body>

</html>