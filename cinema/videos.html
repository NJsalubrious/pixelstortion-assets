<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXELSTORTION // VISUAL ARCHIVE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0"
        rel="stylesheet" />
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
        rel="stylesheet" />
    <style>
        :root {
            --neon-green: #00ff41;
            --neon-dim: rgba(0, 255, 65, 0.1);
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            color: #e0e0e0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .font-mono-custom {
            font-family: 'Courier Prime', monospace;
        }

        /* Glitch & Visuals */
        .glitch-text {
            position: relative;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch-text::before {
            left: 2px;
            text-shadow: -1px 0 red;
            clip-path: inset(0 0 0 0);
            animation: glitch-anim 2s infinite linear alternate-reverse;
        }

        .glitch-text::after {
            left: -2px;
            text-shadow: 1px 0 var(--neon-green);
            clip-path: inset(0 0 0 0);
            animation: glitch-anim 3s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% {
                clip-path: inset(10% 0 80% 0);
            }

            20% {
                clip-path: inset(80% 0 10% 0);
            }

            100% {
                clip-path: inset(30% 0 60% 0);
            }
        }

        .scanlines {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1));
            background-size: 100% 4px;
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 2px;
        }

        /* MENU BUTTONS */
        .protocol-btn {
            text-align: left;
            padding: 12px 16px;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            opacity: 0.5;
            font-family: 'Courier Prime', monospace;
            font-size: 11px;
            letter-spacing: 1px;
            white-space: nowrap;
            cursor: pointer;
        }

        .protocol-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            opacity: 0.8;
        }

        .protocol-btn.active {
            color: var(--neon-green);
            opacity: 1;
            text-shadow: 0 0 5px var(--neon-green);
            font-weight: bold;
        }

        /* DESKTOP LAYOUT */
        @media (min-width: 768px) {
            .protocol-btn {
                border-left: 2px solid transparent;
                border-bottom: none;
            }

            .protocol-btn:hover {
                padding-left: 20px;
            }

            .protocol-btn.active {
                border-left: 2px solid var(--neon-green);
                padding-left: 20px;
                background: linear-gradient(90deg, var(--neon-dim) 0%, transparent 100%);
            }
        }

        /* MOBILE LAYOUT - TIGHT HORIZONTAL SCROLL */
        @media (max-width: 767px) {
            #sidebar-left {
                height: auto;
                flex-shrink: 0;
            }

            .mobile-header {
                display: none;
            }

            #protocol-list {
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                padding: 0;
                border-bottom: 1px solid #222;
                background: #080808;
                height: 40px;
                align-items: center;
            }

            .protocol-btn {
                padding: 0 12px;
                height: 100%;
                display: flex;
                align-items: center;
                border-bottom: 2px solid transparent;
                border-left: none;
                font-size: 10px;
                flex-shrink: 0;
            }

            .protocol-btn.active {
                border-bottom: 2px solid var(--neon-green);
                background: linear-gradient(0deg, var(--neon-dim) 0%, transparent 100%);
            }
        }

        /* TRACK LIST (Right Sidebar) */
        .track-item {
            padding: 10px 12px;
            border-bottom: 1px solid #1a1a1a;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .track-item:hover {
            background: #111;
        }

        .track-item.active {
            background: #1a1a1a;
            border-left: 2px solid var(--neon-green);
        }

        .track-item.active .track-idx {
            color: var(--neon-green);
        }

        /* Controls */
        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #333;
            background: #000;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            border-color: var(--neon-green);
            color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-dim);
        }

        /* Fullscreen */
        body.fullscreen-mode #sidebar-left,
        body.fullscreen-mode #sidebar-right,
        body.fullscreen-mode .header-bar {
            display: none !important;
        }

        body.fullscreen-mode #main-container {
            padding: 0;
        }

        body.fullscreen-mode #video-frame {
            position: fixed;
            inset: 0;
            z-index: 100;
            height: 100vh;
            width: 100vw;
            border: none;
        }

        body.fullscreen-mode #fs-exit-btn {
            display: flex;
        }
    </style>
</head>

<body class="flex flex-col md:flex-row h-screen overflow-hidden bg-black text-white">

    <div class="scanlines"></div>

    <div id="sidebar-left" class="w-full md:w-56 bg-[#080808] border-r border-[#222] flex flex-col z-20">

        <div class="hidden md:block p-6 border-b border-[#222]">
            <h1 class="text-lg font-bold font-mono-custom text-white glitch-text" data-text="ARCHIVE">ARCHIVE</h1>
            <p class="text-[9px] text-gray-500 mt-1 font-mono-custom tracking-widest">CLEARANCE: 4</p>
        </div>

        <div id="protocol-list" class="scrollbar-hide md:flex-1 md:overflow-y-auto">
        </div>

        <div class="hidden md:block p-4 border-t border-[#222]">
            <button onclick="shuffleGlobal()"
                class="w-full py-2 border border-[#333] text-[10px] hover:border-green-500 hover:text-green-500 transition-colors font-mono-custom">GLOBAL
                SHUFFLE</button>
        </div>
    </div>

    <div id="main-container" class="flex-1 flex flex-col relative bg-[#050505]">

        <div id="video-frame"
            class="flex-1 relative bg-black flex items-center justify-center overflow-hidden border-b border-[#222]">
            <div id="youtube-player" class="w-full h-full absolute inset-0"></div>
            <div id="interaction-shield" class="absolute inset-0 z-50 pointer-events-auto" onclick="togglePlay()"></div>

            <button id="fs-exit-btn" onclick="toggleFullscreen()"
                class="hidden absolute top-6 right-6 z-50 bg-black/80 text-white p-3 rounded-full border border-red-500 hover:bg-red-900/50 transition-colors"><span
                    class="material-symbols-outlined">close</span></button>
        </div>

        <div
            class="header-bar h-14 md:h-20 bg-[#080808] border-t border-[#222] flex items-center justify-between px-4 md:px-6 z-20 flex-shrink-0">
            <div class="hidden md:block w-1/3">
                <div class="text-[10px] text-green-500 font-mono-custom mb-1">CURRENT FEED</div>
                <div id="current-title" class="text-sm font-bold truncate text-gray-300">CONNECTING...</div>
            </div>

            <div class="md:hidden w-1/3 overflow-hidden">
                <div id="current-title-mobile" class="text-xs font-bold truncate text-gray-300">...</div>
            </div>

            <div class="flex items-center gap-3 md:gap-4">
                <button class="control-btn" onclick="prevTrack()"><span
                        class="material-symbols-outlined">skip_previous</span></button>
                <button class="control-btn" style="border-color: #555;" onclick="togglePlay()"><span id="play-icon"
                        class="material-symbols-outlined text-2xl">play_arrow</span></button>
                <button class="control-btn" onclick="nextTrack()"><span
                        class="material-symbols-outlined">skip_next</span></button>
            </div>

            <div class="flex items-center justify-end gap-2 md:gap-3 w-1/3">
                <button class="md:hidden text-gray-500" onclick="shuffleGlobal()"><span
                        class="material-symbols-outlined text-sm">shuffle</span></button>
                <button class="text-gray-500 hover:text-green-500" onclick="toggleFullscreen()"><span
                        class="material-symbols-outlined">fullscreen</span></button>
            </div>
        </div>
    </div>

    <div id="sidebar-right"
        class="w-full md:w-64 bg-[#080808] border-l border-[#222] flex flex-col z-20 flex-shrink-0 hidden md:flex">
        <div class="p-4 border-b border-[#222] bg-[#0a0a0a]">
            <h2 class="text-xs font-bold text-gray-400 font-mono-custom tracking-widest">FEED DATA</h2>
        </div>
        <div class="flex-1 overflow-y-auto" id="track-list">
            <div class="p-4 text-xs text-gray-500">Establishing Uplink...</div>
        </div>
    </div>

    <script>
        // --- UPDATED IDS WITH ERROR FIXES ---
        const PLAYLISTS = [
            { id: 'PLCznJy93VqGAzZT1mND7Kl2sBm7gXYjY5', name: 'ISLA VIDEO' },
            { id: 'PLCznJy93VqGDx_9t6D4yiB8MHrfaAoiHU', name: 'ETHEL VIDEO' }, // Updated
            { id: 'PLCznJy93VqGAYV-5ITfKlaSwxF-rGDl_4', name: 'DOMINIC VIDEO' }, // Fixed Duplicate
            { id: 'PLCznJy93VqGDqVB53a_p79ry132TYe7Ql', name: 'STICKY VIDEO' },
            { id: 'PLCznJy93VqGAyLossoIWD15Lx_SRAcRu7', name: 'KINLEY VIDEO' }
        ];

        let PROTOCOLS = PLAYLISTS.map(p => ({ ...p, tracks: [] }));
        let player;
        let currentProtocolIdx = 0;
        let currentTrackIdx = 0;
        let isPlaying = false;
        let isReady = false;

        async function fetchAllPlaylists() {
            const promises = PROTOCOLS.map(async (p, idx) => {
                const rssUrl = `https://www.youtube.com/feeds/videos.xml?playlist_id=${p.id}`;
                const convertUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(rssUrl)}`;

                try {
                    const res = await fetch(convertUrl);
                    const data = await res.json();
                    if (data.status === 'ok') {
                        p.tracks = data.items.map(item => {
                            const vidId = item.guid.split(':').pop();
                            return { id: vidId, title: item.title };
                        });
                    } else {
                        console.log("Empty feed for:", p.name);
                    }
                } catch (e) {
                    console.error("Connection Error", p.name);
                }
            });

            await Promise.all(promises);
            renderProtocols();

            // Safety check: Find first protocol with actual tracks
            const firstValidIdx = PROTOCOLS.findIndex(p => p.tracks.length > 0);
            if (firstValidIdx !== -1) {
                loadProtocol(firstValidIdx);
            } else {
                document.getElementById('current-title').innerText = "NO SIGNAL - CHECK IDS";
            }
        }

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('youtube-player', {
                height: '100%', width: '100%',
                playerVars: { 'controls': 0, 'showinfo': 0, 'rel': 0, 'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0, 'disablekb': 1 },
                events: {
                    'onReady': () => { isReady = true; fetchAllPlaylists(); },
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerStateChange(event) {
            const btn = document.getElementById('play-icon');
            if (event.data == YT.PlayerState.PLAYING) {
                btn.innerText = 'pause'; isPlaying = true;
            } else {
                btn.innerText = 'play_arrow'; isPlaying = false;
            }
            if (event.data == YT.PlayerState.ENDED) nextTrack();
        }

        function renderProtocols() {
            const container = document.getElementById('protocol-list');
            container.innerHTML = PROTOCOLS.map((p, idx) => `
                <div onclick="loadProtocol(${idx})" id="proto-btn-${idx}" class="protocol-btn">
                    ${p.name}
                </div>
            `).join('');
        }

        function loadProtocol(idx) {
            currentProtocolIdx = idx;
            currentTrackIdx = 0;

            document.querySelectorAll('.protocol-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`proto-btn-${idx}`);
            if (btn) btn.classList.add('active');
            if (btn) btn.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });

            renderTrackList();

            if (PROTOCOLS[idx].tracks.length > 0) {
                loadTrack(0);
            }
        }

        function renderTrackList() {
            const container = document.getElementById('track-list');
            const tracks = PROTOCOLS[currentProtocolIdx].tracks;

            if (tracks.length === 0) {
                container.innerHTML = '<div class="p-4 text-xs text-gray-500">No tracks found or bad ID.</div>';
                return;
            }

            container.innerHTML = tracks.map((t, i) => `
                <div onclick="loadTrack(${i})" class="track-item group" id="track-row-${i}">
                    <span class="track-idx font-mono-custom text-[10px] text-gray-600 group-hover:text-white">${(i + 1).toString().padStart(2, '0')}</span>
                    <div class="flex-1"><div class="text-[11px] text-gray-300 font-bold truncate">${t.title.toUpperCase()}</div></div>
                    <span class="material-symbols-outlined text-[14px] text-gray-700 opacity-0 group-hover:opacity-100">play_circle</span>
                </div>
            `).join('');
        }

        function loadTrack(trackIdx) {
            const tracks = PROTOCOLS[currentProtocolIdx].tracks;

            // Safety check to prevent "Playback ID Error"
            if (!tracks || tracks.length === 0 || !tracks[trackIdx]) return;

            currentTrackIdx = trackIdx;
            const track = tracks[trackIdx];

            if (player && player.loadVideoById) {
                player.loadVideoById(track.id);
            }

            const title = track.title.toUpperCase();
            document.getElementById('current-title').innerText = title;
            const mobTitle = document.getElementById('current-title-mobile');
            if (mobTitle) mobTitle.innerText = title;

            document.querySelectorAll('.track-item').forEach(el => el.classList.remove('active'));
            const activeRow = document.getElementById(`track-row-${trackIdx}`);
            if (activeRow) {
                activeRow.classList.add('active');
                activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function togglePlay() {
            if (player && player.pauseVideo) {
                isPlaying ? player.pauseVideo() : player.playVideo();
            }
        }

        function nextTrack() {
            const tracks = PROTOCOLS[currentProtocolIdx].tracks;
            if (tracks.length === 0) return;
            loadTrack((currentTrackIdx + 1) % tracks.length);
        }

        function prevTrack() {
            const tracks = PROTOCOLS[currentProtocolIdx].tracks;
            if (tracks.length === 0) return;
            loadTrack((currentTrackIdx - 1 + tracks.length) % tracks.length);
        }

        function toggleFullscreen() { document.body.classList.toggle('fullscreen-mode'); }

        function shuffleGlobal() {
            const validProtocols = PROTOCOLS.filter(p => p.tracks.length > 0);
            if (validProtocols.length === 0) return;

            const rProto = Math.floor(Math.random() * validProtocols.length);
            // Find the original index of this protocol
            const originalIdx = PROTOCOLS.indexOf(validProtocols[rProto]);

            loadProtocol(originalIdx);

            setTimeout(() => {
                const tracks = validProtocols[rProto].tracks;
                if (tracks.length > 0) {
                    loadTrack(Math.floor(Math.random() * tracks.length));
                }
            }, 100);
        }
    </script>
</body>

</html>
